---
title: DLL(静态链接库-动态链接库)
date: 2020-1-13
categories: 
- DLL
tags: 
- 动态链接库
- 静态链接库
---


# 静态链接库
## 特点
1. 函数的重复使用
2. 模块化
3. 解决代码重用性
4. 假模块化（和模块化本身无关，直接将代码编译到exe中，无法实现动态替换）

# 动态链接库
## 特点
1. 代码在独立的模块里，不需要重新编译程序


## 1.隐式调用
1. 将*.dll和*.lib放到工程目录下
2. 将#pragma comment(lib,"xxx.lib")添加到工程中
3. 加入函数声明:`extern "C" __declspec(dllimport) __stdcall int Add(int x,int y);`，*__declspec(dllimport)* 是导入函数

## 2.显示调用
1. 定义函数指针*定义函数指针*
   - typedef int (__stdcall *lpAdd)(int,int)
2. 声明函数变量
   - lpAdd MyAdd
3. 动态加载dll到内存中
   - HINSTANCE hModule = LoadLibrary("xx.dll");
4. 获取函数地址
   - MyAdd = (lpAdd)GetProcAddress(hModule,"Add");
5. 调用函数
   - int a = MyAdd(1,2);

# 说明
1. Handle代表系统的内核对象，如文件句柄，线程句柄，进程句柄
2. HMOUDLE 应用程序载入的模块
3. HINSTANCE win32下与HMOUDLE是相同的win 16遗留的
4. HWND 窗口句柄

## #都是一个四字节无符号的类型
1. 可读性号
2. 防止程序员当做数字错误运算

# def文件
`
EXPORTS

Add @12
Sub @15 NONAME

`

# 作业
1. 创建静态链接库，并在代码中使用
   - 新建lib
   - 新家class
![PE2](/images/pe/新建类.PNG)
   - .cpp写函数
        ```c
        int Plus(int x,int y)
        {
            return x+y;
        }
        int Sub(int x,int y)
        {
            return x-y;
        }
        int Mul(int x,int y)
        {
            return x*y;
        }
        int Div(int x,int y)
        {
            return x/y;
        }
        ```
        ![PE2](/images/pe/code.PNG)
    - 在头文件中声明
        ```c
        int Plus(int x,int y);
        int Sub(int x,int y);
        int Mul(int x,int y);
        int Div(int x,int y);
        ```
        ![PE2](/images/pe/header.PNG)
    - f7生成，复制debug中的*.lib和文件中的*.h
        ![PE2](/images/pe/lib&h.PNG)
    - 包含头文件，导入lib
        ```c
        #include<stdio.h>

        #include "lib1_test.h"
        #pragma comment(lib,"lib1.lib")

        int main()
        {
            printf("%d\n",Sub(5,4));
            return 0;
        }
        ```
        ![PE2](/images/pe/success1.PNG)
1. 创建动态链接库，使用两种方式进行导出（`__declspec(dllimport)`和`def`）
2. 分别使用显示和隐式链接一个dll
