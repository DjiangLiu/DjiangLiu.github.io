title: win32-创建线程
date: 2020-3-10
categories: 
- win32
- 线程
tags: 
- 临界区
- 线程安全问题
- 临界区使用
- CRITICAL SECTION
---

# 线程安全问题

```
int x = 10;
Thread1                     Thread2
get x                       get x
x++;                        x++;
执行到这里的时候时间片到了。
set x                       set x
x = 11                      x = 11
```

# 临界区的使用
1. 创建`CRITICAL_SECTION cs;`
2. 初始化`InitializeCriticalSection(&cs)
3. 获取令牌`EnterCriticalSection(&cs)`
4. 释放令牌`LeaveCriticalSection(&cs)`
5. 删除`CRITICAL_SECTION` `VOID DeleteCriticalSection(PCRITICAL_SECTION pcs)`

```c
typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        // force size on 64-bit systems when packed
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

LockCount初始值为-1，大于等于0时表示被占用。
RecursionCount此字段包含所有者线程已经获得该临界区的次数
OwningThread包含当前占用此临界区的线程的线程标志符，此线程ID与GetCurrentThreadId所返回的值一致
LockCount - （RecursionCount - 1）等待获取临界区的线程数
```

# 怎样合理使用
1. 如果是读的话可以不用令牌。
2. 如果是写的话，只在写的前后进行控制令牌，比如在while前的话，多线程就变成单线程了。
3. 单个变量，就用自己的令牌。