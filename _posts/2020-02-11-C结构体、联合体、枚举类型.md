---
title: C结构体、联合体、枚举类型
date: 2020-2-11
categories: 
- C
tags: 
- 结构体
- 联合体
- 枚举类型
---

# 结构体
## 基本类型与构建类型
1. 基本类型/内建类型（char short int等）
2. 构建类型(结构体、联合体)

## 结构体定义
1. “结构”由若干成员组成。每一个成员可以是一个基本类型或构造类型

```c
//1
struct MyStruct
{
	int a;
	int b;
};

struct MyStruct2
{
	int a;
	int b;

}struct1, struct2;
//这种只能用str1和str2两个变量名。
struct 
{
	int a;
	int b;
}str1,str2 ;
//这种时常用的
typedef struct MyStruct3
{
	int a;
	int b;
}MyStruct3,*pMyStruct3;
```

2. sizeof(p2), sizeof(*p2), sizeof(MyStruct3)  指针的长度：4。 结构体的长度：36 结构体的长度：36。 p2++  就是移动结构体的长度（36）

```c
#include<stdio.h>
#include<string.h>
#include<malloc.h>

//定义结构体
//1

typedef struct _MyStruct3
{
	int id;
	int age;
	char name[20];
	char sex;
	float score;
}MyStruct3,*pMyStruct3;//pMyStruct3 == MyStruct3*


int main(void)
{
	MyStruct3 s2 = { 0 };
	pMyStruct3 p2 = &s2;
	printf("%s\n", p2->name);
	printf("%d\n%d\n%d\n", sizeof(p2), sizeof(*p2), sizeof(MyStruct3));
	MyStruct3* p3 = (MyStruct3*)malloc(sizeof(MyStruct3));
	if (p3 == NULL)
	{
		return -1;
	}
    memset(p3, 0, sizeof(MyStruct3));
	p3->id = 20;
	strcpy_s(p3->name, 20, "test");
	printf("%d\n%s\n", p3->id, p3->name);
	free(p3);
	p3 == NULL;
	return 0;
}
```

## 结构体中的结构体

```c
#include<stdio.h>
#include<string.h>
#include<malloc.h>

//定义结构体
//1

typedef struct _MyStruct2
{
	int year;
	int mon;
}MyStruct2, pMyStruct2;

typedef struct _MyStruct3
{
	int id;
	int age;
	char name[20];
	char sex;
	float score;
	MyStruct2 data;
}MyStruct3,*pMyStruct3;//pMyStruct3 == MyStruct3*


int main(void)
{
	MyStruct3 s2 = { 0 };
	s2.data.year = 1996;
	s2.data.mon = 2;
	pMyStruct3 p2 = &s2;
	MyStruct3* p3 = (MyStruct3*)malloc(sizeof(MyStruct3));
	if (p3 == NULL)
	{
		return -1;
	}
	memset(p3, 0, sizeof(MyStruct3));
	p3->id = 20;
	p3->data.year = 2002;
	strcpy_s(p3->name, 20, "test");
	printf("%d\n%s\n", p3->id, p3->name);
	free(p3);
	p3 == NULL;
	return 0;
}
```

## 结构体中包含指针

```c
#include<stdio.h>
#include<string.h>
#include<malloc.h>

typedef struct _MyStruct3
{
	int id;
	int age;
	char *name;
	char sex;
	float score;
}MyStruct3,*pMyStruct3;//pMyStruct3 == MyStruct3*


int main(void)
{
	MyStruct3 student = { 1,22,"tom",'M',11.3f };
	MyStruct3 student2 = { 0 };
	student2.name = (char*)malloc(20);
	if (student2.name == NULL)
	{
		return -1;
	}
	memset(student2.name, 0, 20);
	strcpy(student2.name, "hihihi");

	printf("%s\n",student2.name);

	free(student2.name);
	student2.name = NULL;
	return 0;
}
```

## 结构体中的指针结构体
1. 赋值的时候注意深浅copy

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>

typedef struct _Date
{
	int year;
	int mon;
}Date,pDate;

typedef struct _Student
{
	int age;
	char* name;
	Date* date;
}student,pStudent;


int main(void)
{
	student s1 = { 0 };
	s1.age = 20;
	s1.name = (char*)malloc(20);
	if (s1.name == NULL)
	{
		return -1;
	}
	memset(s1.name, 0, 20);
	strcpy(s1.name, "lili");
	s1.date = (Date*)malloc(sizeof(Date));
	if (s1.date == NULL)
	{
		free(s1.name);
		s1.name = NULL;
		return -1;
	}
	memset(s1.date, 0, sizeof(Date));
	s1.date->year = 1999;
	s1.date->mon = 2;

	printf("%s\n%d\n", s1.name, s1.date->mon);
	free(s1.date);
	s1.date = NULL;
	free(s1.name);
	s1.name == NULL;
	return 0;
}
```

## 作业
1. 使用typedef定义一个链表节点
2. 如何使用. ->访问结构体中的成员
3. 如何将结构体数据存放在栈上堆上
4. 利用结构体中next指针实现一个链表的基本操作。


```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>

//这就是一个简单的链表，next指针指向一个一样的结构体。当next==NULL的时候，链表结束
typedef struct _node
{
	int value;
	struct _node* next;
}node,*pnode;

//二叉树。
typedef struct _btree
{
	int data;
	struct _btree* left;
	struct _btree* right;
}btree,*ptree;

int main(void)
{

	return 0;
}
```

# 结构体中使用指针和数组
1. 第一种结构定长
2. 第二种结构使用指针
3. 第三种结构可变长

	```c
	#include<stdio.h>
	#include<malloc.h>
	#include<string.h>
	#include<Windows.h>


	//内存不足或过剩
	typedef struct _Info1
	{
		int value;
		char name[64];
	}Info1,*pInfo1;

	//在copy过程中要堆name的值进行单独的处理
	//这里面name存放的是地址只占四个字节
	typedef struct _Info2
	{
		int value;
		char* name;
	}Info2, *pInfo2;

	//name只存放首字母，后续根据length进行扩展。windows PIMAGE_IMPORT_BY_NAME结构类似  
	typedef struct _Info3
	{
		int value;
		size_t length;
		char name[1];
	}Info3, * pInfo3;

	void Test(void)
	{
		Info1* p1 = (Info1*)malloc(sizeof(Info1));
		Info2* p2 = (Info2*)malloc(sizeof(Info2));
		

		//+1 是test\0 -1是char name[1]
		int len = sizeof(Info3) + strlen("test22") + 1 - 1;
		Info3* p3 = (Info3*)malloc(len);

		if (p1 == NULL)
		{
			goto err;
		}
		memset(p1, 0, sizeof(Info1));
		p1->value = 2;
		strcpy_s(p1->name, 64, "test");

		
		if (p2 == NULL)
		{
			goto err;
		}
		memset(p2, 0, sizeof(Info2));
		p2->value = 12;
		p2->name = (char*)malloc(10);
		if (p2->name == NULL)
		{
			goto err;
		}
		memset(p2->name, 0, 10);
		strcpy_s(p2->name, 10, "test");

		

		if (p3 == NULL)
		{
			goto err;
		}
		memset(p3, 0, len);
		p3->value = 12;
		p3->length = strlen("test22") + 1;

		strcpy_s(p3->name, p3->length, "test22");

		printf("第1个结构体\nname：%s\n大小:%d\n", p1->name, sizeof(Info1));
		printf("第2个结构体\nname：%s\n大小:%d\n", p2->name, sizeof(Info2));
		printf("第3个结构体\nname：%s\n大小:%d\n", p3->name, sizeof(Info3));

	err:
		if (p1)
			free(p1);
		if (p2->name)
			free(p2->name);
		if (p2)
			free(p2);
		if (p3)
		{
			free(p3);
		}

	}

	int main(void)
	{
		Test();
	}
	```

# 结构体浅拷贝深拷贝写时拷贝
## 结构体赋值时的拷贝
1. 结构体中的复制默认是浅copy,即sc.b的和sz.b指向同一块内存。此时sz.b释放，则sc.b也释放
2. S1可以直接copy
3. 浅copy，会出现野指针、数据修改的问题，深copy会造成空间浪费的问题
4. 使用写时copy（使用一个引用计数的问题）


```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _S1
{
	int a;
	char b;
}S1;

typedef struct _S2
{
	int a;
	char* b;
}S2;

void Test(void)
{
	S1 sx;
	sx.a = 1;
	sx.b = 'a';
	S1 sy = sx;

	S2 sz;
	sz.a = 1;
	sz.b = (char*)malloc(10);
	if (sz.b == NULL)
	{
		return;
	}
	memset(sz.b, 0, 10);
	strcpy_s(sz.b, 10, "test2");
	//这种赋值时浅copy
	S2 sc = sz;
	printf("sz: %s\n", sz.b);
	printf("sc: %s\n", sc.b);
	free(sz.b);
	printf("sc: %s\n", sc.b);
}

int main(void)
{
	Test();
}

```

![结构体](/images/cc/结构体.png)

## 深copy使用者自己实现

```c
	S2 sv;
	sv.a = sz.a;
	sv.b = (char*)malloc(10);
	if (sv.b == NULL)
	{
		return;
	}
	memset(sv.b, 0, 10);
	memcpy(sv.b, sz.b, 10);
	free(sz.b);
	printf("SV:%s\n", sv.b);
```

# 结构体应用
## 结构体数据的初始化、遍历、结构体指针数据

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _student
{
	int score;
	char name[12];
}Student,*pStudent;

void Test(void)
{
	Student stu1[3] = { {12,"qq"},{13,"ww"},{14,"ee"} };
	Student stu2[3] = { 0 };
	pStudent stu3[3] = { 0 };
	for (int i = 0; i < 3; i++)
	{
		printf("please input score and name for %d\n", i + 1);
		scanf_s("%d%s", &stu2[i].score, stu2[i].name, 12);
	}
	for (int m = 0; m < 3; m++)
	{
		stu3[m] = &stu1[m];
	}
	for (int n = 0; n < 3; n++)
	{
		printf("%d %s\n", stu1[n].score, stu1[n].name);
		printf("%d %s\n", stu2[n].score, stu2[n].name);
		printf("%d %s\n", stu3[n]->score,stu3[n]->name);
	}
}

int main(void)
{
	Test();
}
```

## 结构体做函数参数
### 传值、传指针

从反汇编中看出，传值是将结构体复制一份然后传给函数，效率低下。传指针则是传结构体的首地址。


```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _student
{
	int score;
	char name[12];
}Student,*pStudent;

int Max1(Student s1, Student s2)
{
	return s1.score > s2.score ? s1.score : s2.score;
}

int Max2(pStudent s1, pStudent s2)
{
	return s1->score > s2->score ? s1->score : s2->score;
}

void Test(void)
{
	Student stu1 = { 13,"tom1" };
	Student stu2 = { 16,"tom2" };
	int a1 = Max1(stu1, stu2);
	int a2 = Max2(&stu1, &stu2);
	printf("%d\n%d\n", a1, a2);
}

int main(void)
{
	Test();
}


	int a1 = Max1(stu1, stu2);
00405120  mov         edx,dword ptr [ebp-24h]  
00405123  mov         dword ptr [eax+0Ch],edx  
00405126  sub         esp,10h  
00405129  mov         eax,esp  
0040512B  mov         ecx,dword ptr [stu1]  
0040512E  mov         dword ptr [eax],ecx  
00405130  mov         edx,dword ptr [ebp-14h]  
00405133  mov         dword ptr [eax+4],edx  
00405136  mov         ecx,dword ptr [ebp-10h]  
00405139  mov         dword ptr [eax+8],ecx  
0040513C  mov         edx,dword ptr [ebp-0Ch]  
0040513F  mov         dword ptr [eax+0Ch],edx  
00405142  call        Max1 (04013CAh)  
00405147  add         esp,20h  
0040514A  mov         dword ptr [a1],eax  
	int a2 = Max2(&stu1, &stu2);
0040514D  lea         eax,[stu2]  
00405150  push        eax  
00405151  lea         ecx,[stu1]  
00405154  push        ecx  
	int a2 = Max2(&stu1, &stu2);
00405155  call        Max2 (04013CFh)  
0040515A  add         esp,8  
0040515D  mov         dword ptr [a2],eax  

```

## 作业
1. 结构在传参时采用哪种方式效率更高

	传值是复制一份在传输，传指针效率更高
2. 利用结构体和指针，实现链表的创建、插入、删除、遍历等操作。

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _node
{
	int value;
	struct _node* next;
}Node, * pNode;

void Test(void)
{
	//方法1：第一个在栈上容易内存泄漏，所以所有的节点都最好在堆上分配。从第一个开始
	/*
	Node node1 = { 0 };
	node1.value = 1;
	node1.next = (pNode)malloc(sizeof(Node));
	if (node1.next == NULL)
	{
		return;
	}
	memset(node1.next, 0, sizeof(Node));
	node1.value = 2;
	node1.next = NULL;
	*/
	//方法2：
	pNode node = (pNode)malloc(sizeof(Node));
	pNode temp = node;
	if (node == NULL)
	{
		return;
	}
	memset(node, 0, sizeof(Node));
	for (int i = 0; i < 10; i++)
	{
		if (i == 10)
		{
			pNode node = NULL;
		}
		else
		{
			node->value = i;
			node->next = (pNode)malloc(sizeof(Node));
			if (node->next == NULL)
			{
				return;
			}
			memset(node->next, 0, sizeof(Node));
			node = node->next;
		}
	}
	node = temp;
	//遍历链表
	for (int j = 0; j < 10; j++)
	{
		if (node != NULL)
		{
			printf("%d\n", node->value);
			node = node->next;
		}
	}
}

int main(void)
{
	Test();
}
```

# 结构体长度