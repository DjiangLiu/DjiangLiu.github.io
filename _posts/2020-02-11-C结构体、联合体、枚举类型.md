---
title: C结构体、联合体、枚举类型
date: 2020-2-11
categories: 
- C
tags: 
- 结构体
- 联合体
- 枚举类型
---

# 结构体
## 基本类型与构建类型
1. 基本类型/内建类型（char short int等）
2. 构建类型(结构体、联合体)

## 结构体定义
1. “结构”由若干成员组成。每一个成员可以是一个基本类型或构造类型

```c
//1
struct MyStruct
{
	int a;
	int b;
};

struct MyStruct2
{
	int a;
	int b;

}struct1, struct2;
//这种只能用str1和str2两个变量名。
struct 
{
	int a;
	int b;
}str1,str2 ;
//这种时常用的
typedef struct MyStruct3
{
	int a;
	int b;
}MyStruct3,*pMyStruct3;
```

2. sizeof(p2), sizeof(*p2), sizeof(MyStruct3)  指针的长度：4 结构体的长度：36 结构体的长度：36 p2++  就是移动结构体的长度（36）

```c
#include<stdio.h>
#include<string.h>
#include<malloc.h>

//定义结构体
//1

typedef struct _MyStruct3
{
	int id;
	int age;
	char name[20];
	char sex;
	float score;
}MyStruct3,*pMyStruct3;//pMyStruct3 == MyStruct3*


int main(void)
{
	MyStruct3 s2 = { 0 };
	pMyStruct3 p2 = &s2;
	printf("%s\n", p2->name);
	printf("%d\n%d\n%d\n", sizeof(p2), sizeof(*p2), sizeof(MyStruct3));
	MyStruct3* p3 = (MyStruct3*)malloc(sizeof(MyStruct3));
	if (p3 == NULL)
	{
		return -1;
	}
    memset(p3, 0, sizeof(MyStruct3));
	p3->id = 20;
	strcpy_s(p3->name, 20, "test");
	printf("%d\n%s\n", p3->id, p3->name);
	free(p3);
	p3 == NULL;
	return 0;
}
```

## 结构体中的结构体

```c
#include<stdio.h>
#include<string.h>
#include<malloc.h>

//定义结构体
//1

typedef struct _MyStruct2
{
	int year;
	int mon;
}MyStruct2, pMyStruct2;

typedef struct _MyStruct3
{
	int id;
	int age;
	char name[20];
	char sex;
	float score;
	MyStruct2 data;
}MyStruct3,*pMyStruct3;//pMyStruct3 == MyStruct3*


int main(void)
{
	MyStruct3 s2 = { 0 };
	s2.data.year = 1996;
	s2.data.mon = 2;
	pMyStruct3 p2 = &s2;
	MyStruct3* p3 = (MyStruct3*)malloc(sizeof(MyStruct3));
	if (p3 == NULL)
	{
		return -1;
	}
	memset(p3, 0, sizeof(MyStruct3));
	p3->id = 20;
	p3->data.year = 2002;
	strcpy_s(p3->name, 20, "test");
	printf("%d\n%s\n", p3->id, p3->name);
	free(p3);
	p3 == NULL;
	return 0;
}
```

## 结构体中包含指针

```c
#include<stdio.h>
#include<string.h>
#include<malloc.h>

typedef struct _MyStruct3
{
	int id;
	int age;
	char *name;
	char sex;
	float score;
}MyStruct3,*pMyStruct3;//pMyStruct3 == MyStruct3*


int main(void)
{
	MyStruct3 student = { 1,22,"tom",'M',11.3f };
	MyStruct3 student2 = { 0 };
	student2.name = (char*)malloc(20);
	if (student2.name == NULL)
	{
		return -1;
	}
	memset(student2.name, 0, 20);
	strcpy(student2.name, "hihihi");

	printf("%s\n",student2.name);

	free(student2.name);
	student2.name = NULL;
	return 0;
}
```

## 结构体中的指针结构体
1. 赋值的时候注意深浅copy

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>

typedef struct _Date
{
	int year;
	int mon;
}Date,pDate;

typedef struct _Student
{
	int age;
	char* name;
	Date* date;
}student,pStudent;


int main(void)
{
	student s1 = { 0 };
	s1.age = 20;
	s1.name = (char*)malloc(20);
	if (s1.name == NULL)
	{
		return -1;
	}
	memset(s1.name, 0, 20);
	strcpy(s1.name, "lili");
	s1.date = (Date*)malloc(sizeof(Date));
	if (s1.date == NULL)
	{
		free(s1.name);
		s1.name = NULL;
		return -1;
	}
	memset(s1.date, 0, sizeof(Date));
	s1.date->year = 1999;
	s1.date->mon = 2;

	printf("%s\n%d\n", s1.name, s1.date->mon);
	free(s1.date);
	s1.date = NULL;
	free(s1.name);
	s1.name == NULL;
	return 0;
}
```

## 作业
1. 使用typedef定义一个链表节点
2. 如何使用. ->访问结构体中的成员
3. 如何将结构体数据存放在栈上堆上
4. 利用结构体中next指针实现一个链表的基本操作。

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>

//这就是一个简单的链表，next指针指向一个一样的结构体。当next==NULL的时候，链表结束
typedef struct _node
{
	int value;
	struct _node* next;
}node,*pnode;

//二叉树。
typedef struct _btree
{
	int data;
	struct _btree* left;
	struct _btree* right;
}btree,*ptree;

int main(void)
{

	return 0;
}
```

# 结构体中使用指针和数组
1. 第一种结构定长
2. 第二种结构使用指针
3. 第三种结构可变长
```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>


//内存不足或过剩
typedef struct _Info1
{
	int value;
	char name[64];
}Info1,*pInfo1;

//在copy过程中要堆name的值进行单独的处理
//这里面name存放的是地址只占四个字节
typedef struct _Info2
{
	int value;
	char* name;
}Info2, *pInfo2;

//name只存放首字母，后续根据length进行扩展。windows PIMAGE_IMPORT_BY_NAME结构类似  
typedef struct _Info3
{
	int value;
	size_t length;
	char name[1];
}Info3, * pInfo3;

void Test(void)
{
	Info1* p1 = (Info1*)malloc(sizeof(Info1));
	Info2* p2 = (Info2*)malloc(sizeof(Info2));
	

	//+1 是test\0 -1是char name[1]
	int len = sizeof(Info3) + strlen("test22") + 1 - 1;
	Info3* p3 = (Info3*)malloc(len);

	if (p1 == NULL)
	{
		goto err;
	}
	memset(p1, 0, sizeof(Info1));
	p1->value = 2;
	strcpy_s(p1->name, 64, "test");

	
	if (p2 == NULL)
	{
		goto err;
	}
	memset(p2, 0, sizeof(Info2));
	p2->value = 12;
	p2->name = (char*)malloc(10);
	if (p2->name == NULL)
	{
		goto err;
	}
	memset(p2->name, 0, 10);
	strcpy_s(p2->name, 10, "test");

	

	if (p3 == NULL)
	{
		goto err;
	}
	memset(p3, 0, len);
	p3->value = 12;
	p3->length = strlen("test22") + 1;

	strcpy_s(p3->name, p3->length, "test22");

	printf("第1个结构体\nname：%s\n大小:%d\n", p1->name, sizeof(Info1));
	printf("第2个结构体\nname：%s\n大小:%d\n", p2->name, sizeof(Info2));
	printf("第3个结构体\nname：%s\n大小:%d\n", p3->name, sizeof(Info3));

err:
	if (p1)
		free(p1);
	if (p2->name)
		free(p2->name);
	if (p2)
		free(p2);
	if (p3)
	{
		free(p3);
	}

}

int main(void)
{
	Test();
}
```
# 结构体浅拷贝深拷贝写时拷贝
## 结构体赋值时的拷贝
1. 结构体中的复制默认是浅copy,即sc.b的和sz.b指向同一块内存。此时sz.b释放，则sc.b也释放
2. S1可以直接copy

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _S1
{
	int a;
	char b;
}S1;

typedef struct _S2
{
	int a;
	char* b;
}S2;

void Test(void)
{
	S1 sx;
	sx.a = 1;
	sx.b = 'a';
	S1 sy = sx;

	S2 sz;
	sz.a = 1;
	sz.b = (char*)malloc(10);
	if (sz.b == NULL)
	{
		return;
	}
	memset(sz.b, 0, 10);
	strcpy_s(sz.b, 10, "test2");
	//这种赋值时浅copy
	S2 sc = sz;
	printf("sz: %s\n", sz.b);
	printf("sc: %s\n", sc.b);
	free(sz.b);
	printf("sc: %s\n", sc.b);
}

int main(void)
{
	Test();
}
```
![结构体](/images/cc/结构体.png)
## 深copy使用者自己实现

```c
	S2 sv;
	sv.a = sz.a;
	sv.b = (char*)malloc(10);
	if (sv.b == NULL)
	{
		return;
	}
	memset(sv.b, 0, 10);
	memcpy(sv.b, sz.b, 10);
	free(sz.b);
	printf("SV:%s\n", sv.b);
```