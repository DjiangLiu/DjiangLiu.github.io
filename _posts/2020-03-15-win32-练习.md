---
title: win32-线程-练习
date: 2020-3-15
categories: 
- win32
- 线程
tags: 
- 练习
---

# 简介
1. 有两个生产者四个消费者之间同步。
2. 两个生产者、四个消费者之间是互斥的。

```c
// win32_thread小结.cpp : 定义应用程序的入口点。
//

#include "framework.h"
#include "win32_thread小结.h"

#define MAX_LOADSTRING 100

// 全局变量:
HINSTANCE hInst;                                // 当前实例
DWORD FlagStrLen;
HWND g_DiaLogMain;
HWND hEdit1;
HWND hEdit2;
HWND hEdit3;
HWND hEdit4;
HWND hEdit5;
HWND hEdit6;
HWND hEdit7;

HANDLE hThread[7];

HANDLE g_hMutex;
HANDLE g_Event1;
HANDLE g_Event2;
HANDLE g_Semaphore;

TCHAR temp[0x10] = { 0 };

DWORD WINAPI ThreadConsumer1(LPVOID lpParameter)
{
	while (true)
	{
		WaitForSingleObject(g_Event1, INFINITE);
		WaitForSingleObject(g_hMutex, INFINITE);
		LPWSTR buffer = (LPWSTR)malloc(0x30);
		if (buffer == NULL)
		{
			return 0;
		}
		memset(buffer, 0, 0x30);
		

		GetWindowText(hEdit5, buffer, 0x30);

		if (_tcsclen_l(buffer) == 0)
		{
			ReleaseMutex(g_hMutex);
			ExitThread(2);
		}

		wsprintf(temp, TEXT("%C"), buffer[0]);
		SetWindowText(hEdit6, temp);

		buffer += 1;
		SetWindowText(hEdit5, buffer);

		Sleep(1000);

		buffer -= 1;
		free(buffer);
		buffer = NULL;
		ReleaseMutex(g_hMutex);
		SetEvent(g_Event2);
	}
	return 1;
}

DWORD WINAPI ThreadConsumer2(LPVOID lpParameter)
{
	while (true)
	{
		WaitForSingleObject(g_Event1, INFINITE);
		WaitForSingleObject(g_hMutex, INFINITE);
		LPWSTR buffer = (LPWSTR)malloc(0x30);
		if (buffer == NULL)
		{
			return 0;
		}
		memset(buffer, 0, 0x30);

		GetWindowText(hEdit5, buffer, 0x30);

		if (_tcsclen_l(buffer) == 0)
		{
			ReleaseMutex(g_hMutex);
			ExitThread(2);
		}

		wsprintf(temp, TEXT("%C"), buffer[0]);
		SetWindowText(hEdit7, temp);

		buffer += 1;
		SetWindowText(hEdit5, buffer);

		Sleep(1000);
		
		buffer -= 1;
		free(buffer);
		buffer = NULL;
		ReleaseMutex(g_hMutex);
		SetEvent(g_Event2);
	}
	return 1;
}

DWORD WINAPI ThreadConsumer3(LPVOID lpParameter)
{
	TCHAR szBuffer[0x10] = { 0 };
	while (true)
	{
		WaitForSingleObject(g_Event2, INFINITE);
		_tcscat_s(szBuffer, 0x10, temp);
		//MessageBox(0, szBuffer, TEXT("1"), 0);
		SetWindowText(hEdit1, szBuffer);
		SetEvent(g_Event1);
	}
	return 1;
}

DWORD WINAPI ThreadConsumer4(LPVOID lpParameter)
{
	TCHAR szBuffer[0x10] = { 0 };
	while (true)
	{
		WaitForSingleObject(g_Event2, INFINITE);
		_tcscat_s(szBuffer, 0x10, temp);
		//MessageBox(0, szBuffer, TEXT("1"), 0);
		SetWindowText(hEdit2, szBuffer);
		SetEvent(g_Event1);
	}
	return 2;
}

DWORD WINAPI ThreadConsumer5(LPVOID lpParameter)
{
	TCHAR szBuffer[0x10] = { 0 };
	while (true)
	{
		WaitForSingleObject(g_Event2, INFINITE);
		_tcscat_s(szBuffer, 0x10, temp);
		//MessageBox(0, szBuffer, TEXT("1"), 0);
		SetWindowText(hEdit3, szBuffer);
		SetEvent(g_Event1);
	}
	return 3;
}

DWORD WINAPI ThreadConsumer6(LPVOID lpParameter)
{
	TCHAR szBuffer[0x10] = { 0 };
	while (true)
	{
		WaitForSingleObject(g_Event2, INFINITE);
		_tcscat_s(szBuffer, 0x10, temp);
		//MessageBox(0, szBuffer, TEXT("1"), 0);
		SetWindowText(hEdit4, szBuffer);
		SetEvent(g_Event1);
	}
	return 4;
}


BOOL CALLBACK DialogProc(
	HWND hwndDlg,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam
)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		g_DiaLogMain = hwndDlg;
		g_hMutex = CreateMutex(NULL, FALSE, TEXT("zzz"));
		g_Event1 = CreateEvent(NULL, FALSE, TRUE, NULL);
		g_Event2 = CreateEvent(NULL, FALSE, FALSE, NULL);
		//g_Semaphore = CreateSemaphore(NULL, 0, 4, NULL);

		hEdit1 = GetDlgItem(g_DiaLogMain, IDC_EDIT1);
		hEdit2 = GetDlgItem(g_DiaLogMain, IDC_EDIT2);
		hEdit3 = GetDlgItem(g_DiaLogMain, IDC_EDIT3);
		hEdit4 = GetDlgItem(g_DiaLogMain, IDC_EDIT4);
		hEdit5 = GetDlgItem(g_DiaLogMain, IDC_EDIT5);
		hEdit6 = GetDlgItem(g_DiaLogMain, IDC_EDIT6);
		hEdit7 = GetDlgItem(g_DiaLogMain, IDC_EDIT7);


		SetWindowText(hEdit5, TEXT("1234567890asdfghjklzx"));

		return TRUE;
	}
	case WM_CLOSE:
	{
		EndDialog(g_DiaLogMain, 0);
		return TRUE;
	}
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDD_OK:
		{
			hThread[0] = CreateThread(NULL, 0, ThreadConsumer1, NULL, 0, NULL);
			hThread[1] = CreateThread(NULL, 0, ThreadConsumer2, NULL, 0, NULL);

			hThread[2] = CreateThread(NULL, 0, ThreadConsumer3, NULL, 0, NULL);
			hThread[3] = CreateThread(NULL, 0, ThreadConsumer4, NULL, 0, NULL);
			hThread[4] = CreateThread(NULL, 0, ThreadConsumer5, NULL, 0, NULL);
			hThread[5] = CreateThread(NULL, 0, ThreadConsumer6, NULL, 0, NULL);
			return TRUE;
		}
		case IDD_OK2:
		{
			::CloseHandle(hThread[0]);
			::CloseHandle(hThread[1]);
			::CloseHandle(hThread[2]);
			::CloseHandle(hThread[3]);
			::CloseHandle(hThread[4]);
			::CloseHandle(hThread[5]);

			EndDialog(g_DiaLogMain, 0);
			return TRUE;
		}
		default:
			break;
		}
	}
	default:
		break;
	}
	return FALSE;
}

int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
	hInst = hInstance;

	DialogBox(NULL, MAKEINTRESOURCE(IDD_DIALOG1), NULL, DialogProc);

	return 0;
}
```

![demo](/images/win32/win32-38.png)
