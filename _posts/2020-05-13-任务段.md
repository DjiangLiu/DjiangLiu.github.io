---
title: 保护模式-任务段
date: 2020-5-13
categories: 
- 保护模式
tags: 
- 任务段
---

# TSS

1. 一块内存
2. 有104字节
3. 存在的目的：替换所有寄存器；切换任务（即线程（CPU没有进程和线程的概念））
4. 切换cr3就是切换进程

## 什么时候需要把所有的寄存器全换掉
1. 单核的前提下，CPU只有一个寄存器，同时只能做一件事。
2. 单核的前提下，一个CPU只有一个TSS。

### 如何实现同时做两件事（两个任务：对应操作系统里面的线程）
1. 分时。A跑到某处将所有的寄存器都存起来，去执行B任务。

### 如何知道寄存器存到哪里了
1. 存到TSS中

### 所有的段寄存器
1. CS
2. SS
3. DS
4. ES
5. FS   0环fs 保存的 dt _KPRCE
6. GS
7. LDTR
8. TR

![TSS](/images/保护模式/tss.png)

### 如果Limit大于104怎么办？
1. 只找前104字节

# 任务段内容分析
1. 0-4字节 link 前一个任务段的链接（指向前一个TSS、段选择子）
2. 96-100 LDT Selector LDT的段选择子。
   1. LDT有多少个，取决于有多少个任务（多少个TSS）、
   2. LDTR：base limit （用来描述LDT表的地址和大小）
3. eflags 第十四位置1
4. ESP0 SS0 ESP1 SS1 ESP2 SS2 没有ss3 应为三环程序不需要切换ss
5. 72-100 段寄存器 保存上一次的值，返回的时候重新修改。


## windows是如何使用的
就是只用了SS0和ESP0，x64已经舍弃了

# 之间的联系
1. TSS是一块内存，至少104字节
2. TR指向当前TSS段描述符的段选择子
3. TSS段描述符

```c
r tr
00000028
00101 0 00
index = 5

```

```c
// call
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
char trs[6]={0};
char gdts[6]={0};

void __declspec(naked)  test()
{
        __asm
        {
                //jmp fword ptr trs;
                iretd;
        }
}

int main(int argc,char * argv[])
{

        char stack[100]={0};
        DWORD cr3=0;
        printf("cr3:");
        scanf("%X",&cr3);

        DWORD tss[0x68]={
                0x0,
                0x0,
                0x0,
                0x0,
                0x0,
                0x0,
                0x0,
                cr3,
                (DWORD)test,
                0,
                0,
                0,
                0,
                0,
                ((DWORD)stack) - 100,
                0,
                0,
                0,
                0x23,
                0x08,
                0x10,
                0x23,
                0x30,
                0,
                0,
                0x20ac0000

        };

        WORD rs=0;
        _asm
        {
                sgdt gdts;
                str ax;
                mov rs,ax;
        }
        *(WORD*)&trs[4]=rs;
        char buf[6]={0,0,0,0,0x48,0};
        __asm
        {
                call fword ptr buf;
        }

        printf("zsaddfsafdsa\n");
        return 0;
}
```

```c
// jmp
#include <stdio.h>
#include <stlib.h>
char trs[6]={0};
char gdts[6]={0};

void __declspec(naked)  test()
{
        __asm
        {
                jmp fword ptr trs;
                //iretd;
        }
}

int main(int argc,char * argv[])
{

        char stack[100]={0};
        DWORD cr3=0;
        printf("cr3:");
        scanf("%X",&cr3);

        DWORD tss[0x68]={
                0x0,
                0x0,
                0x0,
                0x0,
                0x0,
                0x0,
                0x0,
                cr3,
                (DWORD)test,
                0,
                0,
                0,
                0,
                0,
                ((DWORD)stack) - 100,
                0,
                0,
                0,
                0x23,
                0x08,
                0x10,
                0x23,
                0x30,
                0,
                0,
                0x20ac0000

        };

        WORD rs=0;
        _asm
        {
                sgdt gdts;
                str ax;
                mov rs,ax;
        }
        *(WORD*)&trs[4]=rs;
        char buf[6]={0,0,0,0,0x48,0};
        __asm
        {
                jmp fword ptr buf;
        }

        printf("zsaddfsafdsa\n");
        return 0;
}
```