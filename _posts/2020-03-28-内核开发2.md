---
title: 内核开发1
date: 2020-3-28
categories: 
- 驱动框架理解
tags: 
- 第二课
- 框架代码分析
- R3与R0通信
- 内核层与应用层的区别
---

# 驱动框架理解
# 作业讲解
## 1. 统计1的个数

```c
1. 

while(x)
{
    count++;
    x &= (x-1);

}

2. 右移次数多，运算效率低
while(x)
{
    count += (x&1);
    //这种方式需要考虑负数的情况。负数右移左边补符号位
    x >> 1;
}

```

## 把一个数转化为36进制的数

1. 有符号数的最小值，符号位为1，其余的都为0
2. 有符号数的最大值，符号位为0，其余的都为1
3. 不建议在函数中malloc，避免malloc/free分开。
4. 内存和长度作为参数来进行传入。

```c
```

## 判断系统是低位优先还是高位优先

1. 利用int存1，然后用(char*)强转
2. 利用union，保存int和char


```c
```

## 按单词逆置

1. 先将字符串整体逆置
2. 然后再见部分逆置回来，就ok了。
3. 不用任何变量来计算字符串长度
4. 用汇编的方式实现这段代码

# 代码框架分析

## 
引用层API - kernel32.dll(等) - Ntdll - 通过sysentry/syscall - kifastcallentry进入内核 - SSDT表/shadow SSDT表（保存和应用层API相对应的函数） - 封装成一个包（包含请求参数等内容）

1. PAE物理地址扩展，把32位变成36位

## 

1. DriverEntry。
2. 设备对象就是用来接收应用层函数的。
3. 设备对象和驱动对象是互指的。
   1. 驱动对象创建一个设备对象链表。
   2. 设备对象有一个指针指向驱动对象。
4. flags 中间的一个很重的标识 -> 通信方式 DO_BUFFERED_IO
   1. 以什么方式传递数据，存储数据，读取数据。
   2. BUFFERED_IO 将R3传输的数据保存在R0中一段内存中。
   3. 优点安全、缺点效率低
   4. DO_DIRECT_IO
   5. neither_io直接读取内存地址，prohofor
5. DO_DERVICE_INITALIZING   在什么时候取消，在driverentry由操作系统取消，在其他的地方必须要手动去掉
6. 28个分发函数
7. 分发函数可以自己命名
8. 读写操作去最小值：length是应用层发下来的长度，
9. TSET  因为是低位优先  所以调试的时候看到的是TEST


## IRP
1. 封装应用发下来的数据和命令
2. 第一部分头部
   1. IOSTATUS  结构体
      1. sttus  错误码
      2. information    io的相关信息，比如读和写（多了多少字节/写了多少字节）
    2. SystemBuffer
3. 第二部分栈
   1. 设备对象
      1. Majorfunction
      2. mfunction
      3. 联合体

# R3与R0通信
# 内核与应用层通信

# 七种开发的漏洞
# windbg调回
## 线程U
1. ~*kb  调试死锁很好用
2. !runaway 查看线程占用时间
3. .detach  释放
4. du 查看内存中的值
5. bc
6. bl
7. bp address
8. bp module!func
9. bu module!func
10. bm module!fu*c   支持正则的断点
11. ba w4/r4/e1/i4 address //内存断点（IO）
    1.  ba w4 0x81000000
12. bp /p eprocess address/func//进程断点
13. bp /t ethread address/func//线程断点
14. ba /p /t
15. dt 常看系统中每个结构的成员（必须成功加载符号）
    1.  dt nt!_EPROCESS[-r]   内核中进程的内核对象。
    2.  dt [nt!]_PEB Ldr 7ffdf000   查看内核中的值。
16. du 内存中的指针
17. kb/kp/kv 内核层的调用关系。
18. uf address 查看函数反汇编。
19. 如何将内核层数据发给数据层。