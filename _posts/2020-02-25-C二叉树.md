---
title: 数据结构-二叉树
date: 2020-2-25
categories: 
- C
tags: 
- 数据结构
- 二叉树
---

# 简介
1. 新增、查找等性能都很好
![二叉树类型](/images/pe/二叉树类型.png)

# 二叉树特点
1. 根节点：最上面的节点
2. 父节点：相对于下一个节点
3. 子节点：相对于上一个节点
4. 左子树：相对于上一个节点
5. 右子树：相对于上一个节点



# 二叉树的高
![二叉树](/images/pe/二叉树.png)

1. 以某一个节点为根节点的高度


# 二叉树遍历
![二叉树](/images/pe/二叉树.png)
## 前序
根 左 右 G D A D E M H Z

## 中序
左 根 右 D A F E G M H Z

## 后序
左 右 根 D A F E M H Z G

# 代码练习
1. 遍历二叉树列表
2. 完成代码
3. 如何区分二叉树和双向链表

    - 如果一堆数据加三个地址，大概率是二叉树
    - 如果连续出现两个地址，看地址指向的位置。


```c
void destroy_tree(btree *t)
{
	if(t==NULL)
	{
		return;
	}

// 	btree *left=t->left;
// 	btree *right=t->right;
// 	free(t);
// 	destroy_tree(left);
// 	destroy_tree(right);

// 	destroy_tree(t->left);
// 	btree *right=t->right;
// 	free(t);
// 	destroy_tree(right);

	destroy_tree(t->left);
	destroy_tree(t->right);
	free(t);
}
```


```c
#pragma once

#include "stdio.h"
#include "stdlib.h"
#include "windows.h"


class Monster
{
public:
	int ID;
	int Level;
	char Name[20];
public:
	Monster() {}
	Monster(int ID, int Level, char* Name)
	{
		this->ID = ID;
		this->Level = Level;
		memcpy(&this->Name, Name, strlen(Name) + 1);
	}
};

template<class T>
class TreeNode {
public:
	T element;                    //当前节点存储的数据    
	TreeNode<T>* pLeft;                    //指向左子节点的指针    
	TreeNode<T>* pRight;                    //指向右子节点的指针    

	TreeNode(T& ele) {
		//初始化Node节点                    
		memset(&element, 0, sizeof(TreeNode));
		//为元素赋值                    
		memcpy(&element, &ele, sizeof(T));
		pLeft = pRight = NULL;
	}
};

template<class T>
class BSortTree {
public:
	BSortTree();                    //构造函数    
	~BSortTree();                    //析构函数    
public:
	void InOrderTraverse(TreeNode<T>* pNode);                    //中序遍历    
	void PreOrderTraverse(TreeNode<T>* pNode);                    //前序遍历    
	void PostOrderTraverse(TreeNode<T>* pNode);                    //后序遍历    
	TreeNode<T>* GetRoot();                    //返回根节点    
	int GetDepth(TreeNode<T>* pNode);                    //返回某个节点的高度/深度    
private:
	void Init();
	void Clear(TreeNode<T>* pNode);
private:
	TreeNode<T>* m_pRoot;                    //根结点指针    
	int size;                    //树中元素总个数    
};

template<class T>
BSortTree<T>::BSortTree()
{
	Init();
}
template<class T>
BSortTree<T>::~BSortTree() {
	//释放所以节点空间                        
	Clear(m_pRoot);
}

template<class T>
void BSortTree<T>::Init()
{
	Monster m1(1, 1, "刺猬");
	Monster m2(2, 2, "野狼");
	Monster m3(3, 3, "野猪");
	Monster m4(4, 4, "士兵");
	Monster m5(5, 5, "火龙");
	Monster m6(6, 6, "独角兽");
	Monster m7(7, 7, "江湖大盗");

	TreeNode<Monster>* n1 = new TreeNode<Monster>(m1);
	TreeNode<Monster>* n2 = new TreeNode<Monster>(m2);
	TreeNode<Monster>* n3 = new TreeNode<Monster>(m3);
	TreeNode<Monster>* n4 = new TreeNode<Monster>(m4);
	TreeNode<Monster>* n5 = new TreeNode<Monster>(m5);
	TreeNode<Monster>* n6 = new TreeNode<Monster>(m6);
	TreeNode<Monster>* n7 = new TreeNode<Monster>(m7);

	m_pRoot = n5;
	n5->pLeft = n4;
	n5->pRight = n6;
	n4->pLeft = n1;
	n1->pRight = n2;
	n6->pLeft = n3;
	n3->pRight = n7;
	size = 7;
	/*
					/ \
  6
				  /   /
   3
				  \    \
   7

	*/
}

//删除节点
template<class T>
void BSortTree<T>::Clear(TreeNode<T>* pNode) 
{
	/*
		if (pNode != NULL)
	{
		if (pNode->pLeft == NULL && pNode->pRight == NULL)
		{
			delete pNode;
		}
		else
		{
			Clear(pNode->pLeft);
			Clear(pNode->pRight);
		}
	}
	*/
	if (pNode == NULL)
	{
		return;
	}
	Clear(pNode->pLeft);
	Clear(pNode->pRight);
	delete pNode;
}

template<class T>
TreeNode<T>* BSortTree<T>::GetRoot()
{
	return m_pRoot;
}

template<class T>
int BSortTree<T>::GetDepth(TreeNode<T>* pNode)
{
	if (pNode == NULL)
	{
		return 0;
	}
	int m = GetDepth(pNode->pLeft);
	int n = GetDepth(pNode->pRight);
	return (m > n)?(m + 1) : (n + 1);
}

//中序遍历所有怪物,列出怪的名字                    
template<class T>
void BSortTree<T>::InOrderTraverse(TreeNode<T>* pNode)
{
	if (pNode != NULL)
	{
		InOrderTraverse(pNode->pLeft);
		//这里(int)(&(pNode->element)) + 8 如果不转化为int型 就是结构体长度 * 8
		printf("怪物编号：%d 怪物名称：%s\n", *((int*)(&(pNode->element))), (char*)((int)(&(pNode->element)) + 8));
		InOrderTraverse(pNode->pRight);
	}
}

//前序遍历所有怪物,列出怪的名字                                
template<class T>
void BSortTree<T>::PreOrderTraverse(TreeNode<T>* pNode)
{
	if (pNode == NULL)
	{
		return;
	}
	else
	{
		printf("怪物编号：%d 怪物名称：%s\n", *((int*)(&(pNode->element))), (char*)((int)(&(pNode->element)) + 8));
		PreOrderTraverse(pNode->pLeft);
		PreOrderTraverse(pNode->pRight);
	}
}

//后序遍历所有怪物,列出怪的名字                            
template<class T>
void BSortTree<T>::PostOrderTraverse(TreeNode<T>* pNode)
{
	if (pNode == NULL)
	{
		return;
	}
	else
	{
		PostOrderTraverse(pNode->pLeft);
		PostOrderTraverse(pNode->pRight);
		printf("怪物编号：%d 怪物名称：%s\n", *((int*)(&(pNode->element))), (char*)((int)(&(pNode->element)) + 8));
	}
}
```

```c
#include"Tree_Demo.h"
#include<stdio.h>

int main(void)
{
	BSortTree<Monster>* tree = new BSortTree<Monster>;
	printf("二叉树高度：%d\n", tree->GetDepth(tree->GetRoot()));
	//中序
	printf("中序\n");
	tree->InOrderTraverse(tree->GetRoot());
	//后序
	printf("后序\n");
	tree->PostOrderTraverse(tree->GetRoot());
	//前序
	printf("前序\n");
	tree->PreOrderTraverse(tree->GetRoot());

	delete tree;
	return 0;
}
```