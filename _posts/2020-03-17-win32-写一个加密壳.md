---
title: win32-加密壳
date: 2020-3-17
categories: 
- win32
- 加密壳
tags: 
- 加密壳
---

# 加密壳
## 二进制壳
1. 并不改变指令含义，只是对特定代码进行加密。
2. 在执行的时候，在内存中展开的一定是原先的模样。
3. 找到程序的入口点，然后dump出来，就可以实现脱壳了。

## 指令壳


## 加壳程序的编写
### 加密方法
1. 获取shell程序路径。
2. 获取Src程序路径。
3. 将src程序读到内存中，并加密。
4. 在shell程序中新增一个节，并将加密后的src程序追加到shell程序的新增节中。
5. 加壳过程完毕。
6. 壳程序本身就是用来解密的。

### 解密方法
1. 读取壳子模块数据。
2. 解密：得到原来的PE文件
3. 在壳程序跑起来内，已挂起的方式创建进程：CreateProcess。要创建的进程就是壳子本身。

### 注意
1. 在程序真正执行前一点要正确的解密所有代码。
2. 追加代码，并转到真正的OEP。
3. 在解密的代码中，如果使用到API，而系统没有加载。所以解密的函数，都需要自己实现。如果使用静态文件在编译的时候就已经确定了，所以要使用ShellCode。
4. 获取外壳程序的context。
5. 卸载外壳程序的镜像文件。（ZwUnmapViewOfSection）
6. 在指定的位置分配空间：位置就是Src的ImageBase，空间是SizeOfImage（VitrualAllocEx）
7. 如果成功，将Src文件拉伸，并复制到该空间中。
8. 如果申请空间失败，且该Src程序是有重定位表，在任意位置申请空间，然后将PE文件拉伸、复制、修复重定位表。否则返回失败。
9. 修改外壳程序的Context的ImageBase，修改成Src的ImageBase；将Context的OEP修改成Src的OEP。
10. 设置Context，并恢复主线程。
11. 终止外壳程序（最开始的壳，不是CreateProcess），解壳成功。



## 

```c
//写添加代码处。
#include <stdio.h>
#include <malloc.h>
#include <Windows.h>

#define SUCCESS 1
#define FAIL 0
#define SRC "E:\\cmd.exe"
#define SHELL "E:\\calc.exe"
#define SECRET 0x12
#define NewSrc "E:\\calc_new.exe"

size_t GetFileBuffer(const char* FileName,char *& FileBuffer)
{
	FILE* FileHandle;

	errno_t err;
	err = fopen_s(&FileHandle, FileName, "rb");
	if (err != 0)
	{
		return FAIL;
	}

	fseek(FileHandle, 0, SEEK_END);
	int m_iFileLen = ftell(FileHandle);
	fseek(FileHandle, 0, SEEK_SET);

	FileBuffer = (char*)malloc(m_iFileLen * sizeof(char));
	if (FileBuffer == NULL)
	{
		return FAIL;
	}
	memset(FileBuffer, 0, m_iFileLen);

	err = fread_s(FileBuffer, m_iFileLen, m_iFileLen, 1, FileHandle);
	
	fclose(FileHandle);
	return m_iFileLen;

}

int GetFileImageBuffer(char* FileBuffer, char*& FileImageBuffer)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	int ImageBufferLen = pNt->OptionalHeader.SizeOfImage;
	FileImageBuffer = (char*)malloc(ImageBufferLen * (sizeof(char)));
	if (FileImageBuffer == NULL)
	{
		return FAIL;
	}
	memset(FileImageBuffer, 0, ImageBufferLen);

	//复制节
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(FileImageBuffer + pSec->VirtualAddress, FileBuffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);
		pSec++;
	}
	//	char* ImageBuffer
	//复制PE头(DoS头、标准头、可选头、节表)
	memcpy(FileImageBuffer, FileBuffer, pNt->OptionalHeader.SizeOfHeaders);

	return SUCCESS;
}

void GetNewFileDos(char*& ShellFileImageBuffer, int SrcFileLen,char*& NewShellFileImageBuffer)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)ShellFileImageBuffer;
	pNt = (PIMAGE_NT_HEADERS)(ShellFileImageBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(ShellFileImageBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	pNt->OptionalHeader.SizeOfImage = pNt->OptionalHeader.SizeOfImage + SrcFileLen + 0x1000;
	int SizeOfImage = pNt->OptionalHeader.SizeOfImage;
	//printf("%p\n", pDos->e_lfanew);

	if (pDos->e_lfanew > 80)
	{
		int CodeLen = 24 + pNt->FileHeader.SizeOfOptionalHeader + pNt->FileHeader.NumberOfSections * 40;
		for (int i = 0; i < CodeLen; i++)
		{
			*(ShellFileImageBuffer + pDos->e_lfanew - 80 + i) = *(ShellFileImageBuffer + pDos->e_lfanew + i);
		}
		//最后一个节表后面修正40个0
		for (int j = 0; j < 40; j++)
		{
			*(ShellFileImageBuffer + pDos->e_lfanew + CodeLen - 40 + j) = 0;
		}
		// 修正pDos->e_lfanew
		*(ShellFileImageBuffer + 60) = pDos->e_lfanew - 80;
	}

	NewShellFileImageBuffer = (char*)malloc(SizeOfImage);
	if (NewShellFileImageBuffer == NULL)
	{
		return;
	}
	memset(NewShellFileImageBuffer, 0, SizeOfImage);

	memmove(NewShellFileImageBuffer, ShellFileImageBuffer, SizeOfImage - SrcFileLen - 0x1000);
}

int GetAlignment(int Flag, int Alinment)
{

	int x = 0;

	if (Flag % Alinment)
	{
		return ((Flag / Alinment) + 1) * Alinment;
	}
	else
	{
		return Flag;
	}
}

void AddSec(char*& FileImageBuffer, int SrcFileLen)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)FileImageBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileImageBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileImageBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	int NewSecLen = SrcFileLen + 0x1000;
	//pNt->OptionalHeader.SizeOfImage += NewSecLen;

	int FileAlignment = pNt->OptionalHeader.FileAlignment;
	int SectionAlignment = pNt->OptionalHeader.SectionAlignment;

	pNt->FileHeader.NumberOfSections += 1;
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[0] = '.';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[1] = 't';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[2] = 'y';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[3] = 'y';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[4] = 'y';

	int NewSecVirtualAddress = (pSec + pNt->FileHeader.NumberOfSections - 2)->VirtualAddress + (pSec + pNt->FileHeader.NumberOfSections - 2)->SizeOfRawData;
	int NewSecPointerToRawData = (pSec + pNt->FileHeader.NumberOfSections - 2)->PointerToRawData + (pSec + pNt->FileHeader.NumberOfSections - 2)->SizeOfRawData;

	(pSec + pNt->FileHeader.NumberOfSections - 1)->Misc.VirtualSize = NewSecLen;
	(pSec + pNt->FileHeader.NumberOfSections - 1)->SizeOfRawData = NewSecLen;
	(pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress = GetAlignment(NewSecVirtualAddress, SectionAlignment);
	(pSec + pNt->FileHeader.NumberOfSections - 1)->PointerToRawData = GetAlignment(NewSecPointerToRawData, FileAlignment);

	(pSec + pNt->FileHeader.NumberOfSections - 1)->Characteristics = 0xc0000040;
}

void XorFileBuffer(char*& SrcFileBuffer, int FileLen)
{
	for (int i = 0; i < FileLen; i++)
	{
		*(SrcFileBuffer + i) ^= SECRET;
	}
}

void AddSrcToShell(char*& ShellImageBuffer, char* SrcBuffer,int SrcFileLen)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)ShellImageBuffer;
	pNt = (PIMAGE_NT_HEADERS)(ShellImageBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(ShellImageBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		//printf("aaaa:   %p\n", pSec->VirtualAddress);
		pSec++;
	}
	printf("aaaa:   %p\n", (pSec - 1)->VirtualAddress);
	memcpy(ShellImageBuffer + (pSec - 1)->VirtualAddress, SrcBuffer, SrcFileLen);
}

void WriteFile(char* ShellImageBuffer)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)ShellImageBuffer;
	pNt = (PIMAGE_NT_HEADERS)(ShellImageBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(ShellImageBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	int ImageBufferLen = pNt->OptionalHeader.SizeOfImage;
	char* NewShellFileBuffer = (char*)malloc(ImageBufferLen * (sizeof(char)));
	if (NewShellFileBuffer == NULL)
	{
		return ;
	}
	memset(NewShellFileBuffer, 0, ImageBufferLen);

	//复制节
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(NewShellFileBuffer + pSec->PointerToRawData, ShellImageBuffer + pSec->VirtualAddress, pSec->Misc.VirtualSize);
		pSec++;
	}
	//	char* ImageBuffer
	//复制PE头(DoS头、标准头、可选头、节表)
	memcpy(NewShellFileBuffer, ShellImageBuffer, pNt->OptionalHeader.SizeOfHeaders);

	

	FILE* FileHandle;
	errno_t err;
	err = fopen_s(&FileHandle, NewSrc, "wb");
	fseek(FileHandle, 0, SEEK_SET);
	int f2_len = fwrite(NewShellFileBuffer, 1, pNt->OptionalHeader.SizeOfImage, FileHandle);
	if (f2_len != 0)
	{
		printf("写入成功\n");
	}
	fclose(FileHandle);
	free(NewShellFileBuffer);
}

void Test()
{
	//获取源文件，并加密
	char* SrcFileBuffer = NULL;
	int SrcFileLen = GetFileBuffer(SRC, SrcFileBuffer);
	XorFileBuffer(SrcFileBuffer, SrcFileLen);

	//获取Shell的Buffer
	char* ShellFileBuffer = NULL;
	char* ShellFileImageBuffer = NULL;
	char* NewShellFileImageBuffer = NULL;
	int ShellFileLen = GetFileBuffer(SHELL, ShellFileBuffer);
	GetFileImageBuffer(ShellFileBuffer, ShellFileImageBuffer);
	//修改PE头
	GetNewFileDos(ShellFileImageBuffer, SrcFileLen, NewShellFileImageBuffer);
	//新增一个节
	AddSec(NewShellFileImageBuffer, SrcFileLen);
	//把加密后的源代码写到新节中
	AddSrcToShell(NewShellFileImageBuffer, SrcFileBuffer, SrcFileLen);

	WriteFile(NewShellFileImageBuffer);

	free(SrcFileBuffer);
	free(ShellFileBuffer);
	free(ShellFileImageBuffer);
	free(NewShellFileImageBuffer);
}

int main(void)
{
	Test();
	return 0;
}
```


```
//解密代码
#include <stdio.h>
#include <Windows.h>
#include <malloc.h>

#define SECRET 0x12
#define NewSrc "E:\\calc_new.exe"
#define SRC "E:\\calc_new_new.exe"
#define SUCCESS 1
#define FAIL 0

size_t GetFileBuffer(const char* FileName, char *& FileBuffer)
{
	FILE* FileHandle;

	errno_t err;
	err = fopen_s(&FileHandle, FileName, "rb");
	if (err != 0)
	{
		return FAIL;
	}

	fseek(FileHandle, 0, SEEK_END);
	int m_iFileLen = ftell(FileHandle);
	fseek(FileHandle, 0, SEEK_SET);

	FileBuffer = (char*)malloc(m_iFileLen * sizeof(char));
	if (FileBuffer == NULL)
	{
		return FAIL;
	}
	memset(FileBuffer, 0, m_iFileLen);

	err = fread_s(FileBuffer, m_iFileLen, m_iFileLen, 1, FileHandle);

	fclose(FileHandle);
	return m_iFileLen;

}

int GetFileImageBuffer(char* FileBuffer, char*& FileImageBuffer)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	int ImageBufferLen = pNt->OptionalHeader.SizeOfImage;
	FileImageBuffer = (char*)malloc(ImageBufferLen * (sizeof(char)));
	if (FileImageBuffer == NULL)
	{
		return FAIL;
	}
	memset(FileImageBuffer, 0, ImageBufferLen);

	//复制节
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(FileImageBuffer + pSec->VirtualAddress, FileBuffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);
		pSec++;
	}
	//	char* ImageBuffer
	//复制PE头(DoS头、标准头、可选头、节表)
	memcpy(FileImageBuffer, FileBuffer, pNt->OptionalHeader.SizeOfHeaders);

	return SUCCESS;
}

void XorFileBuffer(char*& SrcFileBuffer, int FileLen)
{
	for (int i = 0; i < FileLen; i++)
	{
		*(SrcFileBuffer + i) ^= SECRET;
	}
}

size_t GetSrcFileBuffer(char*FileImageBuffer,char*& SrcFileBuffer)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)FileImageBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileImageBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileImageBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	//大小是最后一个节的大小
	SrcFileBuffer = (char*)malloc((pSec + pNt->FileHeader.NumberOfSections - 1)->SizeOfRawData);
	if (SrcFileBuffer == NULL)
	{
		return FAIL;
	}
	memset(SrcFileBuffer, 0, (pSec + pNt->FileHeader.NumberOfSections - 1)->SizeOfRawData);
	memcpy(SrcFileBuffer, FileImageBuffer + (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress, (pSec + pNt->FileHeader.NumberOfSections - 1)->SizeOfRawData);
	return (pSec + pNt->FileHeader.NumberOfSections - 1)->SizeOfRawData;
}

void test2(char* FileBuffer)
{
	PIMAGE_DOS_HEADER pDos = NULL;
	PIMAGE_NT_HEADERS pNt = NULL;
	PIMAGE_SECTION_HEADER pSec = NULL;

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	FILE* FileHandle;
	errno_t err;
	err = fopen_s(&FileHandle, SRC, "wb");
	fseek(FileHandle, 0, SEEK_SET);
	int f2_len = fwrite(FileBuffer, 1, _msize(FileBuffer), FileHandle);
	if (f2_len != 0)
	{
		printf("写入成功\n");
	}
	fclose(FileHandle);


}

void Test()
{
	char* FileBuffer = NULL;
	int FileLen = 0;
	FileLen = GetFileBuffer(NewSrc, FileBuffer);

	char* FileImageBuffer = NULL;
	GetFileImageBuffer(FileBuffer, FileImageBuffer);

	char* SrcFileBuffer = NULL;
	int SrcFileLen = 0;
	SrcFileLen = GetSrcFileBuffer(FileImageBuffer, SrcFileBuffer);
	
	//将加密后的源代码解密
	XorFileBuffer(SrcFileBuffer, SrcFileLen);

	test2(SrcFileBuffer);

	free(FileBuffer);
	free(FileImageBuffer);
	free(SrcFileBuffer);
}

int main(void)
{
	//ZwUnmapViewOfSection();
	Test();
	return 0;
}
```