---
title: C内存分配
date: 2020-2-10
categories: 
- C
tags: 
- 内存分配
---

# 内存分配与寻址

## 系统虚拟内存空间分布
  1. x86支持32位寻址，也就是2**32 = 4GB内存空间，高2G内核空间，
  2. 0x00000000-0x0000ffff 64KB NULL空间
  3. 0x0000ffff-0x7fff0000 进程空间
  4. 0x7fff0000-0x7fffffff 64KB非法区域
  5. 0x7fffffff-0xffffffff 2GB内核空间
  6. x86可以通过PAE技术，将寻址空间调整到64GB，36位寻址
  7. x64 windows用44位，linux用48位

## 程序内存分布
### 内存分类
1. 堆（heap）
   - malloc free 地址由低到高
   - 大小受限于计算机系统中有效的虚拟内存
   - 运行速度较慢而且容易产生内存碎片（解决方案是什么？）
   - 一般在堆的头部用一个字节存放堆得大小，剩余部分存储的内容由开发人员根据程序计算的需求决定
2. 栈（stack）
   - 系统自动分配回收，增长由高到低
   - 应用层1M到10M。内核层12K到24K不等
   - 系统自动分配，效率较高，但开发人员无法控制
   - 栈是用来记录程序执行时函数调用过程中的活动记录（栈针），参数，返回地址，ebp，局部变量等。
3. 静态区
4. 代码区

    ```c
    .rdata 常量
    .data 数据
    ```

    ![内存分类](/images/cc/内存分类.PNG)

## 内存地址分类和寻址模式
### 内存地址分类
   1. 逻辑地址

       由编译器生成，使用c语言指针时，指针的值就是逻辑地址。对于进程而言有一样的地址空间，所以逻辑地址可能相同。逻辑地址由**段地址+段内偏移**组成。
   2. 线性地址

       由分段机制将逻辑地址转化而来，如果没有分段机制作用，那么逻辑地址就是线性地址。
   3. 物理地址

       物理地址是CPU在存取数据时最终在地址总线上发出电平信号，靠该地址来访问对应的数据。要得到物理地址，必须将逻辑地址经过分段、分页等机制转化而来。
   - 从逻辑地址到物理地址的过程叫寻址，x86主要有实模式分段模型、保护模式扁平模型两种模型
### 寻址模式
1. 实模式分段模型

    - 16位寄存器（64K），20位寻址空间（1M）
    - 每个段64K，共16个段
    - CS、DS寄存器存放的是段的起始地址（末尾4位为0，可不存，相当于seg>>4）
    - IP等寄存器中存储段内偏移
    - 逻辑地址到物理地址：seg<<4 + offset
2. 保护模式扁平模型

    - 32/64位寄存器，32/64位地址
    - 1个寄存器就可以完成整个线性地址空间cs、ds寄存器值固定为0或者定值。无需参与地址计算
    - 逻辑地址到物理地址：页表。
3. 分段模型
   
   在16的系统中，地址总线是20，支持2^20 = 1M，而16的系统却只能表示2^16 = 64KB的寻址空间，所以8086CPU将1MB的空间分为16个逻辑段，每段64KB。段地址就是逻辑段在主页中的起始位置，用16位表示，偏移也用16位表示。不同程序有不同的CS、DS
4. 扁平模型

    当CPU运行32位系统时，linux、win xp/7采用的寻址模型。段主要分四种：内核代码段、内核数据段、用户代码段、用户数据段。内核代码段和内核数据段的CS、DS起始为：0xc000000。用户代码段和用户数据段CS、DS起始为：0x00000000。
5. 实模式

    实模式运行在20位地址总线，寻址空间为1M的16操作系统。段大小为64KB，1MB空间被分为16段。CS DS等存储的是段的起始地址，通过CS<<4+IP进行寻址
6. 保护模式

    32位地址总线，地址使用的是虚拟地址。引入了页表和段描述符，用GDT和LDT段描述符表的数据结构来定义每个段，通过页表进行寻址。