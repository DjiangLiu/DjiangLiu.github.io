---
title: PE新增节、扩大节添加代码
date: 2019-12-30
categories: 
- PE
tags: 
- 新增节
- 添加代码
- 扩大节
---


# 任意空白区
## 要求
1. 向任意节中添加代码
2. int func(int x);根据x向相应的节中添加代码，如果没有节，则返回'没有此节'

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <Windows.h>

#define  PATH "E:\\calc.exe"
#define  MsgADD 0x77d507ea
char Shellcode[] =
{
	0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00,
	0xE8, 0x00, 0x00, 0x00, 0x00,
	0xE9, 0x00, 0x00, 0x00, 0x00
};

char* ReadFile(const char* filename) {
	/*
	读取文件内容，并写入malloc buffer中
	返回值  malloc buffer
	*/
	FILE* file_handle;
	file_handle = fopen(filename, "rb");
	if (file_handle == NULL)
	{
		printf("文件打开失败");
	}
	fseek(file_handle, 0, SEEK_END);
	int file_len = ftell(file_handle);
	char* pBuffer = (char*)malloc(sizeof(char)*file_len);

	memset(pBuffer, 0, file_len);

	fseek(file_handle, 0, 0);

	int buffer_len = fread(pBuffer, 1, file_len, file_handle);
	if (buffer_len = file_len)
	{
		printf("读取成功\n");
	}
	return pBuffer;
}

int File_len(const char* filename)
{
	FILE* file_handle;
	file_handle = fopen(filename, "rb");
	if (file_handle == NULL)
	{
		printf("文件打开失败");
	}
	fseek(file_handle, 0, SEEK_END);
	int file_len = ftell(file_handle);
	fseek(file_handle, 0, 0);
	fclose(file_handle);
	return file_len;
}

void test(char* buffer, char* dfile, int file_len, int sec_num) {

	//unsigned char* pData = (unsigned char*)buffer;

	_IMAGE_DOS_HEADER* pDoS;
	_IMAGE_NT_HEADERS* pNt;
	_IMAGE_SECTION_HEADER* pSec;

	pDoS = (PIMAGE_DOS_HEADER)buffer;
	pNt = (PIMAGE_NT_HEADERS)(buffer + pDoS->e_lfanew);
	//24是标准PE头大小
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* imagebuffer = (char*)malloc(pNt->OptionalHeader.SizeOfImage);
	if (imagebuffer == NULL)
	{
		printf("内存申请失败");
		return;
	}
	memset(imagebuffer, 0, pNt->OptionalHeader.SizeOfImage);

	//复制文件头
	//memcpy(imagebuffer, pData, pNt->OptionalHeader.SizeOfHeaders);

	if (sec_num > pNt->FileHeader.NumberOfSections || sec_num < 1)
	{
		printf("节数量填写错误");
		return;
	}
	//复制节
	for (int j = 0; j < pNt->FileHeader.NumberOfSections; j++)
	{
		//memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->SizeOfRawData);
		int shellcode_len = sizeof(Shellcode) / sizeof(char);
		if (j == sec_num - 1)
		{
			if ((signed)(pSec->SizeOfRawData - pSec->Misc.VirtualSize) > shellcode_len)
			{
				//printf("%d\n", pSec->SizeOfRawData - pSec->Misc.VirtualSize);
				//调整E8 E9地址
				int E8 = MsgADD - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 5);
				int E9 = pNt->OptionalHeader.ImageBase + pNt->OptionalHeader.AddressOfEntryPoint - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 0xa);
				//copy shellcode
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize, Shellcode, shellcode_len);
				//重写E8地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 9, &E8, 4);
				//重写E9地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 0xe, &E9, 4);
				//调整节属性
				int x = pSec->Characteristics;
				int y = (pSec - j)->Characteristics;
				pSec->Characteristics = x | y;
			}
			else
			{
				printf("节空间不足!!!");
				return;
			}
		}

		memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);

		pSec++;
	}

	//调整OEP地址
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);
	pNt->OptionalHeader.AddressOfEntryPoint = (pSec + sec_num - 1)->VirtualAddress + (pSec + sec_num - 1)->Misc.VirtualSize;
	//复制headers
	memcpy(imagebuffer, buffer, pNt->OptionalHeader.SizeOfHeaders);

	char* newbuffer = (char*)malloc(file_len);
	if (newbuffer == NULL)
	{
		printf("内存申请失败");
		return;
	}
	memset(newbuffer, 0, file_len);

	//复制文件头
	memcpy(newbuffer, imagebuffer, pNt->OptionalHeader.SizeOfHeaders);
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(newbuffer + pSec->PointerToRawData, imagebuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}

	FILE* fp;
	fp = fopen(dfile, "wb");
	int f2_len = fwrite(newbuffer, 1, file_len, fp);
	if (f2_len != 0)
	{
		printf("写入成功\n");
	}
	fclose(fp);
	//free(imagebuffer);
	//free(newbuffer);
}

void mb(void)
{
	MessageBox(0, 0, 0, 0);
}

int main(void) {
	char str[] = "E:\\notepad++.exe";
	char file2[] = "E:\\npp\\Notepad++\\1.exe";
	int file_len = File_len(str);
	char* filebuffer = ReadFile(str);
	test(filebuffer, file2, file_len, 7);
	//mb();
	free(filebuffer);
	filebuffer = NULL;
	return 0;
}

```

# 扩大节
# 新增节

## 注意
1. 节的属性是否可以执行，可以复制代码节的属性
2. 判断节的大小是否够用
3. 添加一个节表要注意后面要有一个等长的0结构，需要在节表后面添加80个字节（一个节和一个节大小的0）
4. 在添加节表的时候看最后一个节表后面是否有内容，并不是所有内容都可以覆盖的，有些数据是有用信息（通过提升PE头、提升节表，但是不要动节表后面原来的信息）

## 总结
1. 判断是否可以使用

	`SizeOfHeader - (DOS + 垃圾数据 + PE标记头 +可选头 + 已存在的表节) >= 2个表的大小`
2. 需要修改的数据

	- 添加一个新的节（可以copy一份）
	- 在新增节后面填充一个节大小的00
      - 节的头部是否有足够的空间，如果有（大于80）则直接新增节，如果没有则从NT头开始向前提升
	- 修改PE头中的节的大小
	- 修改`SizeOfImage`的大小
	- 在原有的数据的最后，新增一个节的数据（内存对齐的整数倍）
	- 修正新增节的属性

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

#define  MsgADD 0x77d507ea
char Shellcode[] =
{
	0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00,
	0xE8, 0x00, 0x00, 0x00, 0x00,
	0xE9, 0x00, 0x00, 0x00, 0x00
};


int GetFileLen(char* filename)
{
	FILE* filehandle;
	filehandle = fopen(filename, "rb");
	if (filehandle == NULL)
	{
		return 0;
	}

	fseek(filehandle, 0, SEEK_END);
	int file_len = ftell(filehandle);
	fclose(filehandle);
	return file_len;
}

char* GetFileBuffer(char* filename)
{
	FILE* FileHandle;
	FileHandle = fopen(filename, "rb");

	int FileLen = GetFileLen(filename);
	char* FileBuffer = (char*)malloc(FileLen * sizeof(char));

	if (FileBuffer == NULL)
	{
		return NULL;
	}
	memset(FileBuffer, 0, FileLen * sizeof(char));

	int FileBufferLen = fread(FileBuffer, 1, FileLen, FileHandle);
	if (FileBufferLen == FileLen)
	{
		fclose(FileHandle);
		return FileBuffer;
	}
	else
	{
		return NULL;
	}
}

char* GetImageBuffer(char* filename)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	unsigned char* FileBuffer = (unsigned char*)GetFileBuffer(filename);

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	int ImageBufferLen = pNt->OptionalHeader.SizeOfImage;

	char* ImageBuffer = (char*)malloc(ImageBufferLen*(sizeof(char)));

	if (ImageBuffer == NULL)
	{
		printf("内存申请失败");
		return NULL;
	}
	memset(ImageBuffer, 0, ImageBufferLen);

	//复制节
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(ImageBuffer + pSec->VirtualAddress, FileBuffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);
		pSec++;
	}
	//	char* ImageBuffer
	//复制PE头(DoS头、标准头、可选头、节表)
	memcpy(ImageBuffer, FileBuffer, pNt->OptionalHeader.SizeOfHeaders);
	free(FileBuffer);
	return ImageBuffer;
}


int WriteNewFile(char* sfilename, char* dfilename)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	unsigned char* FileBuffer = (unsigned char*)GetFileBuffer(sfilename);
	char* ImageBuffer = GetImageBuffer(sfilename);
	int FileLen = GetFileLen(sfilename);

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* NewBuffer = (char*)malloc(FileLen*(sizeof(char)));
	if (NewBuffer == NULL)
	{
		return 0;
	}
	memset(NewBuffer, 0, FileLen);

	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(NewBuffer + pSec->PointerToRawData, ImageBuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}
	memcpy(NewBuffer, ImageBuffer, pNt->OptionalHeader.SizeOfHeaders);


	FILE* FileHandle;
	FileHandle = fopen(dfilename, "wb");
	int dFileLen = fwrite(NewBuffer, 1, FileLen, FileHandle);
	if (dFileLen != 0)
	{
		printf("写入成功!\n");
		return 1;
	}
	else
	{
		return 0;
	}
	fclose(FileHandle);
	free(NewBuffer);
	free(ImageBuffer);
}

int WriteNewFileInsertCode(char* buffer, char* dfile, int file_len, int sec_num)
{

	//unsigned char* pData = (unsigned char*)buffer;

	_IMAGE_DOS_HEADER* pDoS;
	_IMAGE_NT_HEADERS* pNt;
	_IMAGE_SECTION_HEADER* pSec;

	pDoS = (PIMAGE_DOS_HEADER)buffer;
	pNt = (PIMAGE_NT_HEADERS)(buffer + pDoS->e_lfanew);
	//24是标准PE头大小
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* imagebuffer = (char*)malloc(pNt->OptionalHeader.SizeOfImage);
	if (imagebuffer == NULL)
	{
		printf("内存申请失败\n");
		return 0;
	}
	memset(imagebuffer, 0, pNt->OptionalHeader.SizeOfImage);

	//复制文件头
	//memcpy(imagebuffer, pData, pNt->OptionalHeader.SizeOfHeaders);
	if (sec_num > pNt->FileHeader.NumberOfSections || sec_num < 1)
	{
		printf("节数量填写错误\n");
		return 0;
	}
	//复制节
	for (int j = 0; j < pNt->FileHeader.NumberOfSections; j++)
	{
		//memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->SizeOfRawData);
		int shellcode_len = sizeof(Shellcode) / sizeof(char);
		if (j == sec_num - 1)
		{
			if ((signed)(pSec->SizeOfRawData - pSec->Misc.VirtualSize) > shellcode_len)
			{
				//printf("%d\n", pSec->SizeOfRawData - pSec->Misc.VirtualSize);
				//调整E8 E9地址
				int E8 = MsgADD - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 5);
				int E9 = pNt->OptionalHeader.ImageBase + pNt->OptionalHeader.AddressOfEntryPoint - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 0xa);
				//copy shellcode
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize, Shellcode, shellcode_len);
				//重写E8地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 9, &E8, 4);
				//重写E9地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 0xe, &E9, 4);
				//调整节属性
				int x = pSec->Characteristics;
				int y = (pSec - j)->Characteristics;
				pSec->Characteristics = x | y;
			}
			else
			{
				printf("节空间不足!\n");
				return 0;
			}
		}

		memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);

		pSec++;
	}

	//调整OEP地址
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);
	pNt->OptionalHeader.AddressOfEntryPoint = (pSec + sec_num - 1)->VirtualAddress + (pSec + sec_num - 1)->Misc.VirtualSize;
	//复制headers
	memcpy(imagebuffer, buffer, pNt->OptionalHeader.SizeOfHeaders);

	char* newbuffer = (char*)malloc(file_len);
	if (newbuffer == NULL)
	{
		printf("内存申请失败!\n");
		return 0;
	}
	memset(newbuffer, 0, file_len);

	//复制文件头
	memcpy(newbuffer, imagebuffer, pNt->OptionalHeader.SizeOfHeaders);
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(newbuffer + pSec->PointerToRawData, imagebuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}

	FILE* fp;
	fp = fopen(dfile, "wb");
	int f2_len = fwrite(newbuffer, 1, file_len, fp);
	if (f2_len != 0)
	{
		fclose(fp);
		printf("写入成功\n");
		return 1;
	}
	fclose(fp);
	free(imagebuffer);
	free(newbuffer);

}

char* GetNewFileBuffer(char* filebuffer)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	pDos = (PIMAGE_DOS_HEADER)filebuffer;
	pNt = (PIMAGE_NT_HEADERS)(filebuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(filebuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);


	if (pDos->e_lfanew >= 80)
	{

		int CodeLen = 24 + pNt->FileHeader.SizeOfOptionalHeader + pNt->FileHeader.NumberOfSections * 40;
		for (int i = 0; i < CodeLen; i++)
		{
			*(filebuffer + pDos->e_lfanew - 80 + i) = *(filebuffer + pDos->e_lfanew + i);
		}
		for (int j = 0; j < 40; j++)
		{
			*(filebuffer + CodeLen - 40 + j) = 0;
		}


		*(filebuffer + 60) = pDos->e_lfanew - 80;
		return filebuffer;
	}
	else
	{
		return NULL;
	}

}



int WriteNewFileInsertSection(char* filebuffer, char* dfilename, int filelen)
{
	char* FileBuffer = GetNewFileBuffer(filebuffer);
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);


	int NewSecLen = pSec->Misc.VirtualSize > pSec->SizeOfRawData ? pSec->Misc.VirtualSize : pSec->SizeOfRawData;
	//修改SizeOfImage
	pNt->OptionalHeader.SizeOfImage += NewSecLen;

	//申请ImageBuffer
	char* ImageBuffer = (char*)malloc(pNt->OptionalHeader.SizeOfImage * sizeof(char));
	if (ImageBuffer == NULL)
	{
		printf("内存申请失败!\n");
		return 0;
	}
	memset(ImageBuffer, 0, pNt->OptionalHeader.SizeOfImage * sizeof(char));

	int FileAlignment = pNt->OptionalHeader.FileAlignment;
	int SectionAlignment = pNt->OptionalHeader.SectionAlignment;

	//修改NumberOfSections
	pNt->FileHeader.NumberOfSections += 1;
	//设置新增节name
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[0] = '.';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[1] = 't';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[2] = 'y';
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Name[3] = 'y';
	//大小复制第一个节的大小
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Misc.VirtualSize = pSec->Misc.VirtualSize;
	//新增节的起始位置在原最后一个节的后面，即上一个节的长度加上一个节的起始地址
	(pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress = ((pSec + pNt->FileHeader.NumberOfSections - 2)->VirtualAddress + (pSec + pNt->FileHeader.NumberOfSections - 2)->SizeOfRawData) % SectionAlignment ? ((((pSec + pNt->FileHeader.NumberOfSections - 2)->VirtualAddress + (pSec + pNt->FileHeader.NumberOfSections - 2)->SizeOfRawData) / SectionAlignment) + 1)*SectionAlignment : ((pSec + pNt->FileHeader.NumberOfSections - 2)->VirtualAddress + (pSec + pNt->FileHeader.NumberOfSections - 2)->SizeOfRawData);
	//大小复制第一个节的大小
	(pSec + pNt->FileHeader.NumberOfSections - 1)->SizeOfRawData = pSec->SizeOfRawData;
	//新增节的起始位置在原最后一个节的后面，即上一个节的长度加上一个节的起始地址

	(pSec + pNt->FileHeader.NumberOfSections - 1)->PointerToRawData = (pSec + pNt->FileHeader.NumberOfSections - 2)->PointerToRawData + (pSec + pNt->FileHeader.NumberOfSections - 2)->SizeOfRawData;

	//属性复制第一个节的属性
	(pSec + pNt->FileHeader.NumberOfSections - 1)->Characteristics = pSec->Characteristics;

	printf("%p\n", (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress);

	int E8 = MsgADD - (pNt->OptionalHeader.ImageBase + (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress + 8 + 5);
	int E9 = pNt->OptionalHeader.ImageBase + pNt->OptionalHeader.AddressOfEntryPoint - (pNt->OptionalHeader.ImageBase + (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress + 8 + 0xa);
	//复制shellcode
	memcpy(ImageBuffer + (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress, Shellcode, 18);

	//重写E8地址
	memcpy(ImageBuffer + (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress + 9, &E8, 4);
	//重写E9地址
	memcpy(ImageBuffer + (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress + 0xe, &E9, 4);

	//调整OEP
	pNt->OptionalHeader.AddressOfEntryPoint = (pSec + pNt->FileHeader.NumberOfSections - 1)->VirtualAddress;

	memcpy(ImageBuffer, FileBuffer, pNt->OptionalHeader.SizeOfHeaders);

	for (int z = 0; z < pNt->FileHeader.NumberOfSections - 1; z++)
	{
		memcpy(ImageBuffer + pSec->VirtualAddress, FileBuffer + pSec->PointerToRawData, pSec->SizeOfRawData);
		pSec++;
	}


	char* NewBuffer = (char*)malloc(pNt->OptionalHeader.SizeOfImage);
	if (NewBuffer == NULL)
	{
		return 0;
	}
	memset(NewBuffer, 0, pNt->OptionalHeader.SizeOfImage);

	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	memcpy(NewBuffer, ImageBuffer, pNt->OptionalHeader.SizeOfHeaders);

	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(NewBuffer + pSec->PointerToRawData, ImageBuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}

	FILE* fp;
	fp = fopen(dfilename, "wb");
	int f2_len = fwrite(NewBuffer, 1, pNt->OptionalHeader.SizeOfImage, fp);
	if (f2_len != 0)
	{
		fclose(fp);
		printf("写入成功\n");
		return 1;
	}
	fclose(fp);
	free(ImageBuffer);
	/*







			*/
	return 1;

}

int main(void)
{
	int flag = 0;
	int num = 0;
	char sstr[] = "E:\\cmd.exe";
	char dstr[] = "E:\\calc22.exe";
	char* FileBuffer = GetFileBuffer(sstr);
	int FileLen = GetFileLen(sstr);
	printf("请选择你需要做的事情:\n0:复制一个新文件,\n1:插入一段代码,\n2:新增一个节,在节中写代码.\n");
	scanf("%d", &num);

	int SecNum = 0;
	if (num == 1)
	{
		printf("请输入在第几个节内新增代码(默认第一个节)\n");
		scanf("%d", &SecNum);
	}

	switch (num)
	{
	case 1:
		flag = WriteNewFileInsertCode(FileBuffer, dstr, FileLen, SecNum);
		break;
	case 2:
		flag = WriteNewFileInsertSection(FileBuffer, dstr, FileLen);
		break;
	default:
		flag = WriteNewFile(sstr, dstr);
		break;
	}
	getchar();
	if (flag == 1)
	{
		printf("执行成功!\n");
		free(FileBuffer);
		return 1;
	}
	else
	{
		printf("执行失败!\n");
		free(FileBuffer);
		return 0;
	}
}
```