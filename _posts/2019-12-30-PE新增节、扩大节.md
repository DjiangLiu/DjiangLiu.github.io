---
title: PE新增节、扩大节添加代码
date: 2019-12-30
categories: 
- PE
tags: 
- 新增节
- 添加代码
- 扩大节
---


# 任意空白区
## 要求
1. 向任意节中添加代码
2. int func(int x);根据x向相应的节中添加代码，如果没有节，则返回'没有此节'

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <Windows.h>

#define  PATH "E:\\calc.exe"
#define  MsgADD 0x77d507ea
char Shellcode[] =
{
	0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00,
	0xE8, 0x00, 0x00, 0x00, 0x00,
	0xE9, 0x00, 0x00, 0x00, 0x00
};

char* ReadFile(const char* filename) {
	/*
	读取文件内容，并写入malloc buffer中
	返回值  malloc buffer
	*/
	FILE* file_handle;
	file_handle = fopen(filename, "rb");
	if (file_handle == NULL)
	{
		printf("文件打开失败");
	}
	fseek(file_handle, 0, SEEK_END);
	int file_len = ftell(file_handle);
	char* pBuffer = (char*)malloc(sizeof(char)*file_len);

	memset(pBuffer, 0, file_len);

	fseek(file_handle, 0, 0);

	int buffer_len = fread(pBuffer, 1, file_len, file_handle);
	if (buffer_len = file_len)
	{
		printf("读取成功\n");
	}
	return pBuffer;
}

int File_len(const char* filename)
{
	FILE* file_handle;
	file_handle = fopen(filename, "rb");
	if (file_handle == NULL)
	{
		printf("文件打开失败");
	}
	fseek(file_handle, 0, SEEK_END);
	int file_len = ftell(file_handle);
	fseek(file_handle, 0, 0);
	fclose(file_handle);
	return file_len;
}

void test(char* buffer, char* dfile, int file_len, int sec_num) {

	//unsigned char* pData = (unsigned char*)buffer;

	_IMAGE_DOS_HEADER* pDoS;
	_IMAGE_NT_HEADERS* pNt;
	_IMAGE_SECTION_HEADER* pSec;

	pDoS = (PIMAGE_DOS_HEADER)buffer;
	pNt = (PIMAGE_NT_HEADERS)(buffer + pDoS->e_lfanew);
	//24是标准PE头大小
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* imagebuffer = (char*)malloc(pNt->OptionalHeader.SizeOfImage);
	if (imagebuffer == NULL)
	{
		printf("内存申请失败");
		return;
	}
	memset(imagebuffer, 0, pNt->OptionalHeader.SizeOfImage);

	//复制文件头
	//memcpy(imagebuffer, pData, pNt->OptionalHeader.SizeOfHeaders);

	if (sec_num > pNt->FileHeader.NumberOfSections || sec_num < 1)
	{
		printf("节数量填写错误");
		return;
	}
	//复制节
	for (int j = 0; j < pNt->FileHeader.NumberOfSections; j++)
	{
		//memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->SizeOfRawData);
		int shellcode_len = sizeof(Shellcode) / sizeof(char);
		if (j == sec_num - 1)
		{
			if ((signed)(pSec->SizeOfRawData - pSec->Misc.VirtualSize) > shellcode_len)
			{
				//printf("%d\n", pSec->SizeOfRawData - pSec->Misc.VirtualSize);
				//调整E8 E9地址
				int E8 = MsgADD - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 5);
				int E9 = pNt->OptionalHeader.ImageBase + pNt->OptionalHeader.AddressOfEntryPoint - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 0xa);
				//copy shellcode
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize, Shellcode, shellcode_len);
				//重写E8地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 9, &E8, 4);
				//重写E9地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 0xe, &E9, 4);
				//调整节属性
				int x = pSec->Characteristics;
				int y = (pSec - j)->Characteristics;
				pSec->Characteristics = x | y;
			}
			else
			{
				printf("节空间不足!!!");
				return;
			}
		}

		memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);

		pSec++;
	}

	//调整OEP地址
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);
	pNt->OptionalHeader.AddressOfEntryPoint = (pSec + sec_num - 1)->VirtualAddress + (pSec + sec_num - 1)->Misc.VirtualSize;
	//复制headers
	memcpy(imagebuffer, buffer, pNt->OptionalHeader.SizeOfHeaders);

	char* newbuffer = (char*)malloc(file_len);
	if (newbuffer == NULL)
	{
		printf("内存申请失败");
		return;
	}
	memset(newbuffer, 0, file_len);

	//复制文件头
	memcpy(newbuffer, imagebuffer, pNt->OptionalHeader.SizeOfHeaders);
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(newbuffer + pSec->PointerToRawData, imagebuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}

	FILE* fp;
	fp = fopen(dfile, "wb");
	int f2_len = fwrite(newbuffer, 1, file_len, fp);
	if (f2_len != 0)
	{
		printf("写入成功\n");
	}
	fclose(fp);
	//free(imagebuffer);
	//free(newbuffer);
}

void mb(void)
{
	MessageBox(0, 0, 0, 0);
}

int main(void) {
	char str[] = "E:\\notepad++.exe";
	char file2[] = "E:\\npp\\Notepad++\\1.exe";
	int file_len = File_len(str);
	char* filebuffer = ReadFile(str);
	test(filebuffer, file2, file_len, 7);
	//mb();
	free(filebuffer);
	filebuffer = NULL;
	return 0;
}

```

# 扩大节
# 新增节

## 注意
1. 节的属性是否可以执行，可以复制代码节的属性
2. 判断节的大小是否够用
3. 添加一个节表要注意后面要有一个等长的0结构，需要在节表后面添加80个字节（一个节和一个节大小的0）
4. 在添加节表的时候看最后一个节表后面是否有内容，并不是所有内容都可以覆盖的，有些数据是有用信息（通过提升PE头、提升节表，但是不要动节表后面原来的信息）

## 总结
1. 判断是否可以使用

	`SizeOfHeader - (DOS + 垃圾数据 + PE标记头 +可选头 + 已存在的表节) >= 2个表的大小`
2. 需要修改的数据

	- 添加一个新的节（可以copy一份）
	- 在新增节后面填充一个节大小的00
	- 修改PE头中的节的大小
	- 修改`SizeOfImage`的大小
	- 在原有的数据的最后，新增一个节的数据（内存对齐的整数倍）
	- 修正新增节的属性