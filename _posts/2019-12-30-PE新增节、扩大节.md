---
title: PE新增节、扩大节添加代码
date: 2019-12-30
categories: 
- PE
tags: 
- 新增节
- 添加代码
- 扩大节
---


# 任意空白区
## 要求
1. 向任意节中添加代码
2. int func(int x);根据x向相应的节中添加代码，如果没有节，则返回'没有此节'

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <Windows.h>

#define  PATH "E:\\calc.exe"
#define  MsgADD 0x77d507ea
char Shellcode[] =
{
	0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00,
	0xE8, 0x00, 0x00, 0x00, 0x00,
	0xE9, 0x00, 0x00, 0x00, 0x00
};

char* ReadFile(const char* filename) {
	/*
	读取文件内容，并写入malloc buffer中
	返回值  malloc buffer
	*/
	FILE* file_handle;
	file_handle = fopen(filename, "rb");
	if (file_handle == NULL)
	{
		printf("文件打开失败");
	}
	fseek(file_handle, 0, SEEK_END);
	int file_len = ftell(file_handle);
	char* pBuffer = (char*)malloc(sizeof(char)*file_len);

	memset(pBuffer, 0, file_len);

	fseek(file_handle, 0, 0);

	int buffer_len = fread(pBuffer, 1, file_len, file_handle);
	if (buffer_len = file_len)
	{
		printf("读取成功\n");
	}
	return pBuffer;
}

int File_len(const char* filename)
{
	FILE* file_handle;
	file_handle = fopen(filename, "rb");
	if (file_handle == NULL)
	{
		printf("文件打开失败");
	}
	fseek(file_handle, 0, SEEK_END);
	int file_len = ftell(file_handle);
	fseek(file_handle, 0, 0);
	fclose(file_handle);
	return file_len;
}

void test(char* buffer, char* dfile, int file_len, int sec_num) {

	//unsigned char* pData = (unsigned char*)buffer;

	_IMAGE_DOS_HEADER* pDoS;
	_IMAGE_NT_HEADERS* pNt;
	_IMAGE_SECTION_HEADER* pSec;

	pDoS = (PIMAGE_DOS_HEADER)buffer;
	pNt = (PIMAGE_NT_HEADERS)(buffer + pDoS->e_lfanew);
	//24是标准PE头大小
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* imagebuffer = (char*)malloc(pNt->OptionalHeader.SizeOfImage);
	if (imagebuffer == NULL)
	{
		printf("内存申请失败");
		return;
	}
	memset(imagebuffer, 0, pNt->OptionalHeader.SizeOfImage);

	//复制文件头
	//memcpy(imagebuffer, pData, pNt->OptionalHeader.SizeOfHeaders);

	if (sec_num > pNt->FileHeader.NumberOfSections || sec_num < 1)
	{
		printf("节数量填写错误");
		return;
	}
	//复制节
	for (int j = 0; j < pNt->FileHeader.NumberOfSections; j++)
	{
		//memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->SizeOfRawData);
		int shellcode_len = sizeof(Shellcode) / sizeof(char);
		if (j == sec_num - 1)
		{
			if ((signed)(pSec->SizeOfRawData - pSec->Misc.VirtualSize) > shellcode_len)
			{
				//printf("%d\n", pSec->SizeOfRawData - pSec->Misc.VirtualSize);
				//调整E8 E9地址
				int E8 = MsgADD - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 5);
				int E9 = pNt->OptionalHeader.ImageBase + pNt->OptionalHeader.AddressOfEntryPoint - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 0xa);
				//copy shellcode
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize, Shellcode, shellcode_len);
				//重写E8地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 9, &E8, 4);
				//重写E9地址
				memcpy(imagebuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 0xe, &E9, 4);
				//调整节属性
				int x = pSec->Characteristics;
				int y = (pSec - j)->Characteristics;
				pSec->Characteristics = x | y;
			}
			else
			{
				printf("节空间不足!!!");
				return;
			}
		}

		memcpy(imagebuffer + pSec->VirtualAddress, buffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);

		pSec++;
	}

	//调整OEP地址
	pSec = (PIMAGE_SECTION_HEADER)(buffer + pDoS->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);
	pNt->OptionalHeader.AddressOfEntryPoint = (pSec + sec_num - 1)->VirtualAddress + (pSec + sec_num - 1)->Misc.VirtualSize;
	//复制headers
	memcpy(imagebuffer, buffer, pNt->OptionalHeader.SizeOfHeaders);

	char* newbuffer = (char*)malloc(file_len);
	if (newbuffer == NULL)
	{
		printf("内存申请失败");
		return;
	}
	memset(newbuffer, 0, file_len);

	//复制文件头
	memcpy(newbuffer, imagebuffer, pNt->OptionalHeader.SizeOfHeaders);
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(newbuffer + pSec->PointerToRawData, imagebuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}

	FILE* fp;
	fp = fopen(dfile, "wb");
	int f2_len = fwrite(newbuffer, 1, file_len, fp);
	if (f2_len != 0)
	{
		printf("写入成功\n");
	}
	fclose(fp);
	//free(imagebuffer);
	//free(newbuffer);
}

void mb(void)
{
	MessageBox(0, 0, 0, 0);
}

int main(void) {
	char str[] = "E:\\notepad++.exe";
	char file2[] = "E:\\npp\\Notepad++\\1.exe";
	int file_len = File_len(str);
	char* filebuffer = ReadFile(str);
	test(filebuffer, file2, file_len, 7);
	//mb();
	free(filebuffer);
	filebuffer = NULL;
	return 0;
}

```

# 扩大节
# 新增节

## 注意
1. 节的属性是否可以执行，可以复制代码节的属性
2. 判断节的大小是否够用
3. 添加一个节表要注意后面要有一个等长的0结构，需要在节表后面添加80个字节（一个节和一个节大小的0）
4. 在添加节表的时候看最后一个节表后面是否有内容，并不是所有内容都可以覆盖的，有些数据是有用信息（通过提升PE头、提升节表，但是不要动节表后面原来的信息）

## 总结
1. 判断是否可以使用

	`SizeOfHeader - (DOS + 垃圾数据 + PE标记头 +可选头 + 已存在的表节) >= 2个表的大小`
2. 需要修改的数据

	- 添加一个新的节（可以copy一份）
	- 在新增节后面填充一个节大小的00
	- 修改PE头中的节的大小
	- 修改`SizeOfImage`的大小
	- 在原有的数据的最后，新增一个节的数据（内存对齐的整数倍）
	- 修正新增节的属性

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

#define  MsgADD 0x77d507ea
char Shellcode[] =
{
	0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00,
	0xE8, 0x00, 0x00, 0x00, 0x00,
	0xE9, 0x00, 0x00, 0x00, 0x00
};


int GetFileLen(char* filename)
{
	FILE* filehandle;
	filehandle = fopen(filename, "rb");
	if (filehandle == NULL)
	{
		return 0;
	}

	fseek(filehandle, 0, SEEK_END);
	int file_len = ftell(filehandle);
	fclose(filehandle);
	return file_len;
}

char* GetFileBuffer(char* filename)
{
	FILE* FileHandle;
	FileHandle = fopen(filename, "rb");

	int FileLen = GetFileLen(filename);
	char* FileBuffer = (char*)malloc(FileLen * sizeof(char));

	if (FileBuffer == NULL)
	{
		return NULL;
	}
	memset(FileBuffer, 0, FileLen * sizeof(char));

	int FileBufferLen = fread(FileBuffer, 1, FileLen, FileHandle);
	if (FileBufferLen == FileLen)
	{
		fclose(FileHandle);
		return FileBuffer;
	}
	else
	{
		return 0;
	}
}

char* GetImageBuffer(char* filename)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	unsigned char* FileBuffer = (unsigned char*)GetFileBuffer(filename);

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	int ImageBufferLen = pNt->OptionalHeader.SizeOfImage;

	char* ImageBuffer = (char*)malloc(ImageBufferLen*(sizeof(char)));

	if (ImageBuffer == NULL)
	{
		printf("内存申请失败");
		return NULL;
	}
	memset(ImageBuffer, 0, ImageBufferLen);

	//复制节
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(ImageBuffer + pSec->VirtualAddress, FileBuffer + pSec->PointerToRawData, pSec->Misc.VirtualSize);
		pSec++;
	}
	//	char* ImageBuffer
	//复制PE头(DoS头、标准头、可选头、节表)
	memcpy(ImageBuffer, FileBuffer, pNt->OptionalHeader.SizeOfHeaders);
	free(FileBuffer);
	return ImageBuffer;
}


int WriteNewFile(char* sfilename, char* dfilename)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	unsigned char* FileBuffer = (unsigned char*)GetFileBuffer(sfilename);
	char* ImageBuffer = GetImageBuffer(sfilename);
	int FileLen = GetFileLen(sfilename);

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* NewBuffer = (char*)malloc(FileLen*(sizeof(char)));
	if (NewBuffer == NULL)
	{
		return 0;
	}
	memset(NewBuffer, 0, FileLen);

	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(NewBuffer + pSec->PointerToRawData, ImageBuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}
	memcpy(NewBuffer, ImageBuffer, pNt->OptionalHeader.SizeOfHeaders);


	FILE* FileHandle;
	FileHandle = fopen(dfilename, "wb");
	int dFileLen = fwrite(NewBuffer, 1, FileLen, FileHandle);
	if (dFileLen != 0)
	{
		printf("写入成功!");
		return 1;
	}
	else
	{
		return 0;
	}
	fclose(FileHandle);
	free(NewBuffer);
	free(ImageBuffer);
}

int WriteNewFileInsertCode(char* sfilename, char* dfilename, int SecNum)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	unsigned char* FileBuffer = (unsigned char*)GetFileBuffer(sfilename);
	char* ImageBuffer = GetImageBuffer(sfilename);
	int FileLen = GetFileLen(sfilename);

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	if (SecNum > pNt->FileHeader.NumberOfSections || SecNum < 1)
	{
		printf("节数不正确");
		return 0;
	}
	printf("222:%p\n", pNt->OptionalHeader.AddressOfEntryPoint);
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		int ShellCodeLen = sizeof(Shellcode) / sizeof(char);
		if (i == SecNum - 1)
		{
			if ((signed)(pSec->SizeOfRawData - pSec->Misc.VirtualSize) >= ShellCodeLen)
			{
				int E8 = MsgADD - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 5);
				int E9 = pNt->OptionalHeader.ImageBase + pNt->OptionalHeader.AddressOfEntryPoint - (pNt->OptionalHeader.ImageBase + pSec->VirtualAddress + pSec->Misc.VirtualSize + 8 + 0xa);
				printf("%p\n%p\n", E8, E9);

				memcpy(ImageBuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize, Shellcode, ShellCodeLen);
				memcpy(ImageBuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 9, &E8, 5);
				memcpy(ImageBuffer + pSec->VirtualAddress + pSec->Misc.VirtualSize + 0xe, &E9, 5);

				int x = pSec->Characteristics;
				int y = (pSec - i)->Characteristics;
				pSec->Characteristics = x | y;
			}
			else
			{
				printf("节容量不够！");
				return 0;
			}
		}
		memcpy(ImageBuffer + pSec->VirtualAddress, FileBuffer + pSec->PointerToRawData, pSec->SizeOfRawData);
		pSec++;
	}

	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);
	pNt->OptionalHeader.AddressOfEntryPoint = (pSec + SecNum - 1)->VirtualAddress + (pSec + SecNum - 1)->Misc.VirtualSize;
	//复制headers
	memcpy(ImageBuffer, FileBuffer, pNt->OptionalHeader.SizeOfHeaders);





	printf("111:%p\n", pNt->OptionalHeader.AddressOfEntryPoint);

	char* NewBuffer = (char*)malloc(FileLen*(sizeof(char)));
	if (NewBuffer == NULL)
	{
		return 0;
	}
	memset(NewBuffer, 0, FileLen);

	for (int j = 0; j < pNt->FileHeader.NumberOfSections; j++)
	{
		memcpy(NewBuffer + pSec->PointerToRawData, ImageBuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}
	memcpy(NewBuffer, ImageBuffer, pNt->OptionalHeader.SizeOfHeaders);

	FILE* FileHandle;
	FileHandle = fopen(dfilename, "wb");
	int dFileLen = fwrite(NewBuffer, 1, FileLen, FileHandle);
	if (dFileLen != 0)
	{
		printf("写入成功!");
		fclose(FileHandle);
		free(NewBuffer);
		free(ImageBuffer);
		return 1;
	}
	else
	{
		fclose(FileHandle);
		free(NewBuffer);
		free(ImageBuffer);
		return 0;
	}


}

int WriteNewFileInsertSection(char* sfilename, char* dfilename)
{
	PIMAGE_DOS_HEADER pDos;
	PIMAGE_NT_HEADERS pNt;
	PIMAGE_SECTION_HEADER pSec;

	unsigned char* FileBuffer = (unsigned char*)GetFileBuffer(sfilename);

	pDos = (PIMAGE_DOS_HEADER)FileBuffer;
	pNt = (PIMAGE_NT_HEADERS)(FileBuffer + pDos->e_lfanew);
	pSec = (PIMAGE_SECTION_HEADER)(FileBuffer + pDos->e_lfanew + 24 + pNt->FileHeader.SizeOfOptionalHeader);

	char* ImageBuffer = GetImageBuffer(sfilename);
	int FileLen = GetFileLen(sfilename);

	char* NewBuffer = (char*)malloc(FileLen*(sizeof(char)));
	if (NewBuffer == NULL)
	{
		return 0;
	}
	memset(NewBuffer, 0, FileLen);

	memcpy(NewBuffer, ImageBuffer, pNt->OptionalHeader.SizeOfHeaders);
	for (int i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		memcpy(NewBuffer + pSec->PointerToRawData, ImageBuffer + pSec->VirtualAddress, pSec->SizeOfRawData);
		pSec++;
	}

	FILE* FileHandle;
	FileHandle = fopen(dfilename, "wb");
	int dFileLen = fwrite(NewBuffer, 1, FileLen, FileHandle);
	if (dFileLen != 0)
	{
		printf("写入成功!");
		return 1;
	}
	else
	{
		return 0;
	}
	fclose(FileHandle);
	free(NewBuffer);
	free(ImageBuffer);
}

int main(void)
{
	int flag = 0;
	int num = 0;
	char sstr[] = "E:\\calc.exe";
	char dstr[] = "E:\\calc22.exe";
	printf("请选择你需要做的事情:\n0:复制一个新文件,\n1:插入一段代码,\n2:新增一个节,在节中写代码.\n");
	scanf("%d", &num);

	int SecNum = 0;
	if (num == 1)
	{
		printf("请输入在第几个节内新增代码(默认第一个节):");
		scanf("%d", &SecNum);
	}

	switch (num)
	{
	case 1:
		flag = WriteNewFileInsertCode(sstr, dstr, SecNum);
		break;
	case 2:
		flag = WriteNewFileInsertSection(sstr, dstr);
		break;
	default:
		flag = WriteNewFile(sstr, dstr);
		break;
	}

	if (flag == 1)
	{
		printf("执行成功");
		return 1;
	}
	else
	{
		printf("执行失败!");
		return 0;
	}
}
```