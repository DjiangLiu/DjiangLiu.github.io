---
title: C链表
date: 2020-2-1９
categories: 
- C
tags: 
- 数据结构
- 链表
---

# 时间复杂度
1. 算法中基本操作重复执行的次数：4n^2+5   8n^2+1时间复杂度都是O(n^2)，取最高次并去掉系数。
2. 常数阶O(1) 对数阶O(logn) 线性阶O(n) 平方阶O(n^k) 指数阶O(2^n) 线性对数阶O(nlogn)

# 空间复杂度
1. 动态分配的空间、栈所需要的的空间

# 单向链表
1. 插入时O(1)，查找某一个节点O(n)

```c
typedef struct _node
{
	int value;
	struct _node* next;
}Node, * pNode;
```

## 创建一个结表

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _node
{
	int value;
	struct _node* next;
}Node, * pNode;

pNode creat_simplest_list(int nLength)
{
	pNode node = (pNode)malloc(sizeof(Node));
	pNode temp = node;
	if (node == NULL)
	{
		return NULL;
	}
	memset(node, 0, sizeof(Node));
	for (int i = 0; i < nLength; i++)
	{
		if (i == nLength)
		{
			pNode node = NULL;
		}
		else
		{
			node->value = i * i;
			node->next = (pNode)malloc(sizeof(Node));
			if (node->next == NULL)
			{
				return NULL;
			}
			memset(node->next, 0, sizeof(Node));
			node = node->next;
		}
	}
	return temp;
}

void Test(void)
{
	pNode node = creat_simplest_list(10);
	for (int j = 0; j < 10; j++)
	{
		if (node != NULL)
		{
			printf("%d\n", node->value);
			node = node->next;
		}
	}
	free(node);
}

int main(void)
{
	Test();
}
```

## 头部插入一个结

- 插入节点
  - 插到链表头部。p->next = h ; h = p;
  - 插到链表尾部。先遍历链表。q->next = p ; p->next = NULL; 

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>

typedef struct _node
{
	int value;
	struct _node* next;
}Node, * pNode;

pNode creat_simplest_list(int nLength)
{
	pNode node = (pNode)malloc(sizeof(Node));
	pNode temp = node;
	if (node == NULL)
	{
		return NULL;
	}
	memset(node, 0, sizeof(Node));
	for (int i = 0; i < nLength; i++)
	{
		if (i == nLength - 1)
		{
			node->next = NULL;
            node->value = i * i;
		}
		else
		{
			node->value = i * i;
			node->next = (pNode)malloc(sizeof(Node));
			if (node->next == NULL)
			{
				return NULL;
			}
			memset(node->next, 0, sizeof(Node));
			node = node->next;
		}
	}
	return temp;
}

void Test(void)
{
	//1. 从头节点插入
	pNode new_node = (pNode)malloc(sizeof(Node));
	if (new_node == NULL)
	{
		return;
	}
	memset(new_node, 0, sizeof(Node));
	new_node->value = 99;

	pNode node = creat_simplest_list(10);
	if (node == NULL)
	{
		return;
	}
	new_node->next = node;
	node = new_node;

	for (int j = 0; j < 11; j++)
	{
		if (node != NULL)
		{
			printf("%d\n", node->value);
			node = node->next;
		}
	}

	free(new_node);
	free(node);
}

int main(void)
{
	Test();
}
```

## 链表结尾插入一个结

```c
#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<Windows.h>

typedef struct _node
{
	int value;
	struct _node* next;
}Node, * pNode;

pNode creat_simplest_list(int nLength)
{
	pNode node = (pNode)malloc(sizeof(Node));
	pNode temp = node;
	if (node == NULL)
	{
		return NULL;
	}
	memset(node, 0, sizeof(Node));
	for (int i = 0; i < nLength; i++)
	{
		if (i == nLength - 1)
		{
			node->value = i * i;
			node->next = NULL;
		}
		else
		{
			node->value = i * i;
			node->next = (pNode)malloc(sizeof(Node));
			if (node->next == NULL)
			{
				return NULL;
			}
			memset(node->next, 0, sizeof(Node));
			node = node->next;
		}
	}
	return temp;
}

pNode Test(void)
{
	//1. 从尾节点插入
	pNode new_node = (pNode)malloc(sizeof(Node));
	if (new_node == NULL)
	{
		return NULL;
	}
	memset(new_node, 0, sizeof(Node));
	new_node->value = 99;

	pNode node = creat_simplest_list(10);
	pNode temp = node;
	if (node == NULL)
	{
		return NULL;
	}

	while (node->next)
	{
		node = node->next;
	}
	
	node->next = new_node;
	new_node->next = NULL;

	return temp;
}

int main(void)
{
	pNode p = Test();

	for (int j = 0; j < 100; j++)
	{
		if (p != NULL)
		{
			printf("%d\n", p->value);
			p = p->next;
		}
	}

}


```

## 销毁链表

```c
销毁列表
用临时指针把当前节点记录下来，然后获得下一个地址后销毁这个地址。
void test()
{
	pNode p = Test();
	while (p != NULL)
	{
		pNode q = p;
		p = p->next;
		free(q);
	}
}
```

## 链表删除一个结点

```c
删除其中一个结

pNode del_(int n)
{
	pNode h = insert();
	pNode p = h;
	pNode q = NULL;
	if (h == NULL)
	{
		return NULL;
	}

	while (p != NULL)
	{
		if (p->value == n)
		{
			if (p == h)
			{
				h = h->next;
				free(p);
				p == NULL;
				return h;
			}
			else
			{
				q->next = p->next;
				free(p);
				p == NULL;
				return h;
			}
		}
		q = p;
		p = p->next;
		if (p == NULL)
		{
			return NULL;
		}
	}
}

int main(void)
{
	pNode p = del_(8);
	if (p != NULL)
	{
		printf("删除成功");
	}
	else
	{
		printf("没找到对应的结点，删除不成功");
	}
}
```

## 链表插入非头部\尾部

# 单向循环链表
