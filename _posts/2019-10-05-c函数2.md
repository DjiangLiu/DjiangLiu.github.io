---
title: C 函数2
date: 2019-10-05
categories: 
- C
tags: 
- C 函数2
- 内核安全入门
---

demo1
```
#include <stdio.h>

void func1(int x)
{
    /*传值的方式
    x是a的替身，虽然值一样，但是本质不一样。
    指向的内存地址不一样
    无法在函数内部通过修改形参的值改变实参
    61fecc
    61feb0
    */
    x = 1;
    printf("func1 : %x\n",&x);
    
}

void func2(int &x)
{
    //传实参的地址，相当于别名
    x = 1;
    printf("func2 : %x\n",&x);
}

void func3(int *x)
{
    //传指针，形参*x是对a地址的拷贝，x就是a
    //*x 的地址就是a的地址，
    *x = 3;
    printf("func3 : %x\n",&*x);
}

void swap1(int &a,int &b)
{
    a = a^b;
    b = a^b;
    a = a^b;
}

void swap2(int *a,int *b)
{
    *a = *a^*b;
    *b = *a^*b;
    *a = *a^*b;
}

int add1(int x,int y)
{
    return x+y;
}

void add2(int x,int y,int *sum)
{
    if (sum==NULL)
    {
        return;
    }  
    *sum = x + y;
}

void add3(int x,int y,int &sum)
{
    sum = x + y;
}

void add4(int *x,int y)
{
    *x = *x + y;
}

void add5(int &x,int y)
{
    x = x + y;
}

void print_array1(int a[])
{
    //溢出
	for (int i = 0; i < 10; i++)
	{
		printf("%d", a[i]);
	}
	printf("\n");
}

void print_array2(int a[],size_t len)
{
    //传长度
	for (int i = 0; i < len; i++)
	{
		printf("%d", a[i]);
	}
	printf("\n");
}

void print_array3(int (&a)[9])
{
    //传引用，在编译阶段发现问题
	for (int i = 0; i < 9; i++)
	{
		printf("%d", a[i]);
	}
	printf("\n");
}

int main(void)
{
    int a = 2;
    int x = 1,y = 2;
    printf("%d  %d\n",x,y);
    swap2(&x,&y);
    printf("%d  %d\n",x,y);
    swap1(x,y);
    printf("%d  %d\n",x,y);
    printf("main : %x\n",&a);
    printf("befor func1 a : %d\n",a);
    func1(a);
    printf("after func1 a : %d\n",a);
    func2(a);
    printf("after func2 a : %d\n",a);
    func3(&a);//传指针的地址
    printf("after func3 a : %d\n",a);
    
    
    printf("%d\n",add1(x,y));
    int sum = 0;
    add2(x,y,&sum);
    printf("%d\n",sum);

    add3(x,y,sum);
    printf("%d\n",sum);

    add4(&x,y);
    printf("%d\n",x);

    x = 1,y = 2;
    add5(x,y);
    printf("%d\n",x);

    int arr[9] = {1,2,3,4,5,6,7,8,9};
    print_array1(arr);
    print_array2(arr,9);
    print_array3(arr);

    getchar();
    return 0;
}
```
demo2
```
//分析下面程序出现的问题
两种修改方式


void GetMemory(char *p)
{
    p = (char *)malloc(100);
}
void test(char *s)
{
    char *str = NULL;
    GetMemory(str);
    //首先GetMemory是传值，不会修改实参的内容，所以执行完第一步时str依然为NULL
    系统确实给p分配了内存，函数执行完，未释放，导致内存泄露
    strcpy(str,s);
    str为NULL，cpy会崩溃
    printf(str);
}



void GetMemory(char **p)
{
    *p = (char *)malloc(100);
}
void test(char *s)
{
    char *str = NULL;
    GetMemory(&str);
    strcpy_s(str,100,s);
    printf(str);
    free(str);
}


void GetMemory(char *&p)
{
    p = (char *)malloc(100);
}
void test(char *s)
{
    char *str = NULL;
    GetMemory(str);
    strcpy_s(str,100,s);
    printf(str);
    free(str);
}
```
demo3
```
#include <stdio.h>

void func1(char c[])
{
    printf("%d\n",sizeof(c));
    //4
}

void func2(char &c)
{
    printf("%d\n",sizeof(c));
    //1
}

void func3(char (&c)[9])
{
    printf("%d\n",sizeof(c));
    //9
}

int main(void)
{
    /*数组名本身就是数组的首地址
    数组名就是一个常量指针
    所以
    func1 传递的是一个指针
    func2为1
    func3
    */
    char c[] = "12345678";
    printf("%d\n",sizeof(c));
    func1(c);
    func2(*c);
    func3(c);
    getchar();
    return 0;
}
```